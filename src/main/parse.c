/*
 *  pqR : A pretty quick version of R
 *  Copyright (C) 2013, 2014, 2015, 2016, 2017, 2018, 2019 by Radford M. Neal
 *
 *  Based on R : A Computer Language for Statistical Data Analysis
 *  Copyright (C) 1995, 1996, 1997  Robert Gentleman and Ross Ihaka
 *  Copyright (C) 1997--2010  The R Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#define USE_FAST_PROTECT_MACROS
#include "IOStuff.h"		/*-> Defn.h */
#include "Fileio.h"
#include "Parse.h"
#include <R_ext/Print.h>
#include <Rconnections.h>

#if !defined(__STDC_ISO_10646__) && (defined(__APPLE__) || defined(__FreeBSD__))
/* This may not be 100% true (see the comment in rlocales.h),
   but it seems true in normal locales */
# define __STDC_ISO_10646__
#endif

#include <R_ext/rlocale.h>

#ifdef HAVE_LANGINFO_CODESET
# include <langinfo.h>
#endif


/* --------------------------------------------------------------------------
   PARSING ENTRY POINTS PROVIDED
 
   The following routines, declared in R_ext/Parse.h, parse up to n
   expressions (any number if n is -1) and return their values in a
   single expression vector.
 
     SEXP R_ParseVector (SEXP *text, int n, ParseStatus *status, SEXP srcfile)

     SEXP R_ParseStream (int (*getc)(void *), void *getc_arg, int n, 
                         ParseStatus *status, SEXP srcfile);

   The following routine is similar to R_ParseStream, except it always
   uses Rconn_getc, and is declared in the less public Parse.h:

     SEXP R_ParseConn   (Rconnection con, int n,
                         ParseStatus *status, SEXP srcfile);

   The following routine, also in Parse.h, parses a single expression:
 
     SEXP R_Parse1Stream (int (*getc)(void *), void *getc_arg, 
                          ParseStatus *status, SrcRefState *state,
                          int no_peeking, int retain, char *saved_ps)

   If 'no_peeking' is non-zero, peeking past a newline for an "else"
   following an "if" clause is not done, so at the outer level an
   "else" on a new line will not be seen as part of the "if".  If
   'retain' is non-zero, the parse state is initialized from
   'saved_ps'.  If 'saved_ps' is not null, before returning the parse
   state is saved there (must be an area of R_parse_state_size bytes).

   The R_InitSrcRefState and R_FinalizeSrcRefState routines (which in
   fact deal with more than source references) will need to be used in
   conjunction with the R_Parse1Stream routine.  Calls to these two
   routines must be paired, with the protect stack at the same level
   for the call of R_FinalizeSrcRefState as after the call of
   R_InitSrcRefState.  However, a non-local error exit (causing the
   call of R_FinalizeSrcRefState to be bypassed) is allowed.  Note
   that R_FinalizeSrcRefState may allocate storage, so objects needed
   after its call must be protected before its call (and hence before
   the call of R_InitializeSrcRefState, or using REPROTECT after a
   PROTECT call before).  R_TextForSrcRefState may also be needed.

   The success of the parse is indicated as follows:
 
 	status = PARSE_NULL       - there was no statement to parse
 		 PARSE_OK	  - complete statement
 		 PARSE_ERROR      - syntax error
 		 PARSE_EOF	  - end of file

   PARSE_NULL and PARSE_EOF are not possible for R_ParseVector,
   R_ParseStream, and R_ParseConn.

   If PARSE_ERROR is returned, the error message and context is in 
   the global variables R_ParseErrorMsg, R_ParseContext, etc., which
   are declared in Defn.h.

   This module also defines the isValidName function, since it needs to 
   know the list of reserved words.
*/


/* --------------------------------------------------------------------------
   GRAMMAR FROM THE OLD BISON VERSION OF THE PARSER, WITHOUT THE ACTIONS

   The parser was previously a bottom-up one, generated by Bison.  It is
   now a top-down one, done by recursive descent, but there are traces
   of the old Bison version in some names and comments.  The grammar
   below is now shown just for (possibly out-of-date) documentation.

   Note that the preedence table given is misleading, since the declared 
   precedence applies only when the grammar is ambiguous. */

#if 0

/* This is the precedence table, low to high */

%left		'?'
%left		LOW WHILE FOR REPEAT
%right		IF
%left		ELSE
%right		LEFT_ASSIGN
%right		EQ_ASSIGN
%left		RIGHT_ASSIGN
%left		'~' TILDE
%left		OR OR2
%left		AND AND2
%left		UNOT NOT
%nonassoc   	GT GE LT LE EQ NE
%left		'+' '-'
%left		'*' '/'
%left		SPECIAL
%left		':'
%left		UMINUS UPLUS
%right		'^'
%left		'$' '@'
%left		NS_GET NS_GET_INT
%nonassoc	'(' '[' LBB

prog	:	END_OF_INPUT			
	|	'\n'				
	|	expr_or_assign '\n'		
	|	expr_or_assign ';'		
	|	error	 			
	;

expr_or_assign  :    expr                     
                |    equal_assign               
                ;

equal_assign    :    expr EQ_ASSIGN expr_or_assign  
                ;

expr	: 	NUM_CONST			
	|	STR_CONST			
	|	NULL_CONST			
	|	SYMBOL				

	|	'{' exprlist '}'		
	|	'(' expr_or_assign ')'		

	|	'-' expr %prec UMINUS		
	|	'+' expr %prec UMINUS		
	|	'!' expr %prec UNOT		
	|	'~' expr %prec TILDE		
	|	'?' expr			

	|	expr ':'  expr			
	|	expr '+'  expr			
	|	expr '-' expr			
	|	expr '*' expr			
	|	expr '/' expr			
	|	expr '^' expr 			
	|	expr SPECIAL expr		
	|	expr '%' expr			
	|	expr '~' expr			
	|	expr '?' expr			
	|	expr LT expr			
	|	expr LE expr			
	|	expr EQ expr			
	|	expr NE expr			
	|	expr GE expr			
	|	expr GT expr			
	|	expr AND expr			
	|	expr OR expr			
	|	expr AND2 expr			
	|	expr OR2 expr			

	|	expr LEFT_ASSIGN expr 		
	|	expr RIGHT_ASSIGN expr 		
	|	FUNCTION '(' formlist ')' cr expr_or_assign %prec LOW
	|	expr '(' sublist ')'		
	|	IF ifcond expr_or_assign 	
	|	IF ifcond expr_or_assign ELSE expr_or_assign	
	|	FOR forcond expr_or_assign %prec FOR 	
	|	WHILE cond expr_or_assign	
	|	REPEAT expr_or_assign		
	|	expr LBB sublist ']' ']'	
	|	expr '[' sublist ']'		
	|	SYMBOL NS_GET SYMBOL		
	|	SYMBOL NS_GET STR_CONST		
	|	STR_CONST NS_GET SYMBOL		
	|	STR_CONST NS_GET STR_CONST	
	|	SYMBOL NS_GET_INT SYMBOL	
	|	SYMBOL NS_GET_INT STR_CONST	
	|	STR_CONST NS_GET_INT SYMBOL	
	|	STR_CONST NS_GET_INT STR_CONST	
	|	expr '$' SYMBOL			
	|	expr '$' STR_CONST		
	|	expr '@' SYMBOL			
	|	expr '@' STR_CONST		
	|	NEXT				
	|	BREAK				
	;


cond	:	'(' expr ')'			
	;

ifcond	:	'(' expr ')'			
	;

forcond :	'(' SYMBOL IN expr ')' 		
	;


exprlist:					
	|	expr_or_assign			
	|	exprlist ';' expr_or_assign	
	|	exprlist ';'			
	|	exprlist '\n' expr_or_assign	
	|	exprlist '\n'			
	;

sublist	:	sub				
	|	sublist cr ',' sub		
	;

sub	:					
	|	expr				
	|	SYMBOL EQ_ASSIGN 		
	|	SYMBOL EQ_ASSIGN expr		
	|	STR_CONST EQ_ASSIGN 		
	|	STR_CONST EQ_ASSIGN expr	
	|	NULL_CONST EQ_ASSIGN 		
	|	NULL_CONST EQ_ASSIGN expr	
	;

formlist:					
	|	SYMBOL				
	|	SYMBOL EQ_ASSIGN expr		
	|	formlist ',' SYMBOL		
	|	formlist ',' SYMBOL EQ_ASSIGN expr 
	;

cr	:	
	;
#endif


/* --------------------------------------------------------------------------
   INTERFACE GOING FROM THE PARSER -> THE LEXICAL ANALYSER -> CHARACTER INPUT

   The xxgetc function returns the next character; xxungetc pushes a
   character back to be returned by xxgetc later.  The convention
   followed is that after a character is "peeked at" (eg, to see if
   ">" is followed by "=" to make the ">=" token), it will be pushed
   back with xxungetc.

   The xxgetc function gets a character by calling the function pointed 
   to by ps->ptr_getc, which is set to different functions for different
   input sources. 

   The xxgetc function also maintains the lineno, etc. for source
   references in ps->sr, and the context for error reporting in 
   ps->ParseContext (later copied to R_ParseContext). 

   The get_next_token function obtains the next token, calling xxgetc
   as required, and returning 1 if end of file is encountered
   immediately.  Its argument is 1 if a symbol or unary operator is
   not expected (allowing ".." and "!!" to be seen), though it will
   get a symbol or unary op anyway, as long as it doesn't start with
   ".." and isn't "!".  The convention for get_next_token is that a
   "lookahead" token after what has been parsed so far is normally
   present (the opposite of the convention for xxgetc). */


static int xxgetc(void);       /* Return next input character, or EOF */
static void xxungetc(int);     /* Put back a character */

static int get_next_token(int); /* Update ps->next_token to the next token, and
                                   ps->next_token_val to an associated value */


/* Codes for token types.  ASCII codes for single characters also act as
   token numbers.  

   Note that '\n' is returned at the end of a line of input text, and
   is treated the same as end of file if the expression could end
   there.  Otherwise, it is skipped as a token; however note that
   newline_before_token is set when the following token is returned. */

enum token_type {
  UNUSED=256,   END_OF_INPUT,   ERROR,     STR_CONST,        NUM_CONST,
  SYMBOL,       LEFT_ASSIGN,    EQ_ASSIGN, RIGHT_ASSIGN,     NULL_CONST,
  FUNCTION,     LBB,            FOR,       IN,               IF,
  ELSE,         WHILE,          NEXT,      BREAK,            REPEAT,
  GT,           GE,             LT,        LE,               EQ,
  NE,           AND,            OR,        AND2,             OR2,
  NS_GET,       NS_GET_INT,     EXPT2,     SPECIAL,          COLON_ASSIGN,
  DOTDOT,       BANGBANG,       WITHGRAD,  TRACKGRAD,        BACKGRAD,
  COMPUTEGRAD
};

/* Names for tokens with codes >= 256.  These must correspond in order
   with the codes for token types above.  They are used for error messages,
   and text for "with gradient", etc. in parse data. */

static const char *const token_name[] = {
  "input",      "end of input", "input",   "string constant","numeric constant",
  "symbol",     "assignment",   "=",       "->",             "'NULL'",
  "'function'", "'[['",         "'for'",   "'in'",           "'if'",
  "'else'",     "'while'",      "'next'",  "'break'",        "'repeat'",
  "'>'",        "'>='",         "'<'",     "'<='",           "'=='",
  "'!='",       "'&'",          "'|'",     "'&&'",           "'||'",
  "'::'",       "':::'",        "'**'",    "SPECIAL",        "':='",
  "'..'",       "'!!'",         "'with gradient'", "'track gradient'",
                                "'back gradient'", "'compute gradient'"
};

#define NUM_TRANSLATED 7  /* Number above (at front) that are translated */

#if 0  /* These are just here to trigger the internationalization. */
    _("end of input");
    _("input");
    _("string constant");
    _("numeric constant");
    _("symbol");
    _("assignment");
    _("end of line");  /* currently unused */
#endif

/* Another set of names for tokens with codes >= 256.  These ones are used
   for the results of getParseData. */

static const char *const pdata_token_name[] = {
  "INPUT",      "END_OF_INPUT", "ERROR",   "STR_CONST",      "NUM_CONST",
  "SYMBOL",     "LEFT_ASSIGN",  "EQ_ASSIGN", "RIGHT_ASSIGN", "NULL_CONST",
  "FUNCTION",   "LBB",          "FOR",     "IN",             "IF",
  "ELSE",       "WHILE",        "NEXT",    "BREAK",          "REPEAT",
  "GT",         "GE",           "LT",      "LE",             "EQ",
  "NE",         "AND",          "OR",      "AND2",           "OR2",
  "NS_GET",     "NS_GET_INT",   "^",       "SPECIAL",        "COLON_ASSIGN",
  "DOTDOT",     "BANGBANG",     "WITHGRAD","TRACKGRAD",      "BACKGRAD",
  "COMPUTEGRAD"
};


/* Record of the start and end of part of the source text.  See the
   information in help(srcfile). */

typedef struct
{
  int first_line;
  int first_column;
  int first_byte;

  int last_line;
  int last_column;
  int last_byte;
  
  int first_parsed;
  int last_parsed;
} source_location;

static source_location location_last_expr;  /* location of last expr parsed */


/* --------------------------------------------------------------------------
   POINTER TO THE COMPLETE STATE OF THE PARSER

   The structure pointed to is allocated on the stack, local to the
   outermost parsing function, then referenced by this static global
   pointer in many routines.  This pointer is saved and then restored
   in the xxgetc function, allowing the parser to be called
   recursively as part of getting an input character. */

static struct parse_state *ps; /* currently active parse */

struct parse_state {

    int parse_dotdot;          /* Recognize the .. operator? */

    /* The next token from the input, and asociated variables and functions. */

    int next_token;            /* The next token, as an integer code */
    SEXP next_token_val;       /* The value associated with next_token */
    int newline_before_token;  /* 1 if next token was preceded by '\n' */

    int keep_source;           /* Attach source references to R expressions? */

    source_location token_loc; /* Location data for the lookahead token */
    source_location prev_token_loc;  /*  ... and the one previous to it */

    SrcRefState *sr;           /* Pointer to source reference info */

    /* Context for error report */

    char ParseContext[PARSE_CONTEXT_SIZE];  /* Circular buffer */
    int ParseContextLast;
    int ParseContextLine;

    /* State of character getting and ungetting (see xxgetc below). */

    int (*ptr_getc)(void);     /* Function to call to get a character */

    TextBuffer *textb_ptr;
    Rconnection conn;
    void *stream_getc_arg;
    int (*stream_getc)(void *);

#   define PUSHBACK_BUFSIZE 16

    int pushback[PUSHBACK_BUFSIZE];

    int prevlines[PUSHBACK_BUFSIZE];
    int prevcols[PUSHBACK_BUFSIZE];
    int prevbytes[PUSHBACK_BUFSIZE];
    int prevparse[PUSHBACK_BUFSIZE];

    unsigned int npush;
    int prevpos;
};

const int attribute_hidden R_parse_state_size = sizeof (struct parse_state);


/* --------------------------------------------------------------------------
   DECLARATIONS AND ROUTINES TO SUPPORT PRODUCTION OF PARSE DATA

   See help(getParseData), and its R-level implementation for the final
   format of the data returned.  A temporary linked record format is
   used during parsing, then converted to the format seen at the R
   level in R_FinalizeSrcRefState. */

#define PDATA_ROWS 8           /* Rows in the parseData matrix */

#define PDATA_FIRST_PARSED 0   /* Indexes for rows in the parseData matrix */
#define PDATA_FIRST_COLUMN 1
#define PDATA_LAST_PARSED  2
#define PDATA_LAST_COLUMN  3
#define PDATA_TERMINAL     4
#define PDATA_TOKEN        5   /* Not set in pqR version - always NA */
#define PDATA_ID           6
#define PDATA_PARENT       7

#define PDATA_REC_LEN    5     /* Number of elements in parseData records */

#define PDATA_REC_LINK   0
#define PDATA_REC_IDATA  1
#define PDATA_REC_TOKEN  2
#define PDATA_REC_TEXT   3
#define PDATA_REC_UPLINK 4

#define PDATA_IDATA_VAL(pd,ix) \
    INTEGER (VECTOR_ELT (pd, PDATA_REC_IDATA)) [ix]


/* Routine to be called for each token seen and each expression (or other
   construct) parsed, that creates a parse data record for it, with some 
   information filled in. */

static SEXP start_parseData_record (source_location *start_loc, 
                                    const char *token, const char *text, 
                                    int terminal)
{
    SEXP idat, rec, up;

    if (!ps->keep_source) return R_NilValue;

    /* Allocate a record for this syntactic object, and add it to the
       front of the linked list of parse data records. */

    rec = allocVector (VECSXP, PDATA_REC_LEN);
    SET_VECTOR_ELT (rec, PDATA_REC_LINK, ps->sr->ParseData);
    REPROTECT (ps->sr->ParseData = rec, ps->sr->ParseDataProt);

    /* Set the parent of this record to the record of the current 
       containing object.  (But this may be changed later.)  This
       record then becomes the new containing record. */

    up = ps->sr->containing_parse_rec;
    SET_VECTOR_ELT (rec, PDATA_REC_UPLINK, up);
    ps->sr->containing_parse_rec = rec;

    /* Allocate space for the integer portion of the record. */

    idat = allocVector (INTSXP, PDATA_ROWS);
    Rf_set_elements_to_NA (idat, 0, 1, PDATA_ROWS);

    /* Put information in the record.  The last parsed and column fields
       can't be filled in yet, however. */

    SET_VECTOR_ELT (rec, PDATA_REC_IDATA,  idat);
    SET_VECTOR_ELT (rec, PDATA_REC_TOKEN,  mkChar(token));
    SET_VECTOR_ELT (rec, PDATA_REC_TEXT,   mkChar(text));

    INTEGER(idat)[PDATA_FIRST_PARSED] = start_loc->first_parsed;
    INTEGER(idat)[PDATA_FIRST_COLUMN] = start_loc->first_column;
    INTEGER(idat)[PDATA_TERMINAL] = terminal;
    INTEGER(idat)[PDATA_PARENT] = 
      up == R_NilValue ? 0 : PDATA_IDATA_VAL (up, PDATA_ID);

    INTEGER(idat)[PDATA_ID] = ps->sr->next_id;
    ps->sr->next_id += 1;

    return rec;
}

/* Routine to be called to complete a parse data record, once the end 
   location is known.  Also updates the containing record to account
   for this expression being finished. */

static void end_parseData_record (SEXP rec, source_location *end_loc)
{
    if (rec == R_NilValue) return;

    /* Store the end location in the parse data record. */

    PDATA_IDATA_VAL (rec, PDATA_LAST_PARSED) = end_loc->last_parsed;
    PDATA_IDATA_VAL (rec, PDATA_LAST_COLUMN) = end_loc->last_column;

    /* Make the containing record be the one containing this record. */

    ps->sr->containing_parse_rec = 
      VECTOR_ELT (ps->sr->containing_parse_rec, PDATA_REC_UPLINK);
}

/* Find the n'th previous token record. */

static SEXP prev_token_rec (int n)
{
    SEXP rec = ps->sr->ParseData; 

    while (rec != R_NilValue) {
        if (PDATA_IDATA_VAL (rec, PDATA_TERMINAL)) {
            n -= 1;
            if (n == 0) break;
        }
        rec = VECTOR_ELT (rec, PDATA_REC_LINK);
    }

    return rec;
}

/* Set the parent record and parent id of a parse data record (if it's
   not R_NilValue), to another record (setting parent id to 0 if this 
   one is R_NilValue). */

static void set_parent_in_rec (SEXP rec, SEXP parent_rec)
{
    if (rec != R_NilValue) {
        SET_VECTOR_ELT (rec, PDATA_REC_UPLINK, parent_rec);
        PDATA_IDATA_VAL (rec, PDATA_PARENT) = parent_rec == R_NilValue ? 0
         : PDATA_IDATA_VAL (parent_rec, PDATA_ID);
    }
}

/* Change the token identifier string in a record.  This is used to 
   change to pretend token types, such as SYMBOL_FORMALS, that are
   used to put some higher-level syntactic context into the token
   itself. */

static void set_token_in_rec (SEXP rec, const char *token)
{
    if (rec != R_NilValue)
        SET_VECTOR_ELT (rec, PDATA_REC_TOKEN, mkChar(token));
}

/* Change the text string in a record.  Needed for "with gradient", etc. */

static void set_text_in_rec (SEXP rec, const char *text)
{
    if (rec != R_NilValue)
        SET_VECTOR_ELT (rec, PDATA_REC_TEXT, mkChar(text));
}

/* Set comments outside any expression (and not previously handled) to 
   have MINUS the id of the current top-level expression as their parent. */

static void set_initial_comments_parent (void)
{
    SEXP rec, prec;

    prec = ps->sr->ParseData;

    if (prec == R_NilValue || ps->sr->unattached_comment_id == 0)
        return;

    while (VECTOR_ELT (prec, PDATA_REC_UPLINK) != R_NilValue) 
        prec = VECTOR_ELT (prec, PDATA_REC_UPLINK);

    int PID = - PDATA_IDATA_VAL (prec, PDATA_ID);

    rec = ps->sr->ParseData;

    while (rec != R_NilValue) {
        if (PDATA_IDATA_VAL (rec, PDATA_PARENT) == 0
             && strcmp ("COMMENT", CHAR(VECTOR_ELT(rec,PDATA_REC_TOKEN))) == 0)
            PDATA_IDATA_VAL (rec, PDATA_PARENT) = PID;
        if (PDATA_IDATA_VAL(rec,PDATA_ID) == ps->sr->unattached_comment_id)
            break;
        rec = VECTOR_ELT (rec, PDATA_REC_LINK);
    }

    ps->sr->unattached_comment_id = 0;
}

/* A kludge routine that deletes the second from the latest parse data
   record.  Used to fix up arg lists with keywords, like f(k=x), where
   k initially looks like it could be an expression.  Fiddles IDs too. */

static void delete_second_parseData_record (void)
{
    if (!ps->keep_source) return;

    SEXP rec1 = ps->sr->ParseData;
    if (rec1 == R_NilValue) abort();
    SEXP rec2 = VECTOR_ELT(rec1,PDATA_REC_LINK);
    if (rec2 == R_NilValue) abort();
    SEXP rec3 = VECTOR_ELT(rec2,PDATA_REC_LINK);
    if (rec3 == R_NilValue) abort();

    SET_VECTOR_ELT (rec1, PDATA_REC_LINK, VECTOR_ELT(rec2,PDATA_REC_LINK));

    PDATA_IDATA_VAL (rec1, PDATA_ID) -= 1;
    ps->sr->next_id -= 1;

    set_parent_in_rec (rec3, ps->sr->containing_parse_rec);
}


/* --------------------------------------------------------------------------
   CHARACTER INPUT ROUTINES
*/

static int xxgetc(void)
{

    int c, oldpos;

    if (ps->npush > 0)
        c = ps->pushback[--(ps->npush)];
    else {
        /* Note that the getc function might call the parser recursively. */
        struct parse_state *sv_ps = ps;
        c = ps->ptr_getc();
        ps = sv_ps;
    }

    oldpos = ps->prevpos;
    ps->prevpos = (ps->prevpos + 1) % PUSHBACK_BUFSIZE;
    ps->prevbytes[ps->prevpos] = ps->sr->xxbyteno;
    ps->prevlines[ps->prevpos] = ps->sr->xxlineno;  
    ps->prevparse[ps->prevpos] = ps->sr->xxparseno;

    /* We only advance the column for the 1st byte in UTF-8, so handle later 
       bytes specially */

    if (0x80 <= (unsigned char) c && (unsigned char) c <= 0xBF 
                                  && known_to_be_utf8) {
    	ps->sr->xxcolno--;   
    	ps->prevcols[ps->prevpos] = ps->prevcols[oldpos];
    } else 
    	ps->prevcols[ps->prevpos] = ps->sr->xxcolno;

    if (c == '\n') {
	ps->sr->xxlineno += 1;
	ps->sr->xxcolno = 0;
    	ps->sr->xxbyteno = 0;
    	ps->sr->xxparseno += 1;
    } else {
        ps->sr->xxcolno += 1;
    	ps->sr->xxbyteno += 1;
    }

    if (c == '\t') ps->sr->xxcolno = ((ps->sr->xxcolno + 7) & ~7);
    	
    if (c == EOF)
	return R_EOF;
    
    ps->ParseContextLast = (ps->ParseContextLast + 1) % PARSE_CONTEXT_SIZE;
    ps->ParseContext[ps->ParseContextLast] = c;
    ps->ParseContextLine = ps->sr->xxlineno;    

    return c;
}

static void xxungetc(int c)
{
    /* This assumes that c was the result of xxgetc; if not, some edits will 
       be needed */

    ps->sr->xxlineno = ps->prevlines[ps->prevpos];
    ps->sr->xxbyteno = ps->prevbytes[ps->prevpos];
    ps->sr->xxcolno  = ps->prevcols[ps->prevpos];
    ps->sr->xxparseno = ps->prevparse[ps->prevpos];
    
    ps->prevpos = (ps->prevpos + PUSHBACK_BUFSIZE - 1) % PUSHBACK_BUFSIZE;

    ps->ParseContextLine = ps->sr->xxlineno;

    ps->ParseContext[ps->ParseContextLast] = '\0';
    /* precaution as to how % is implemented for < 0 numbers */
    ps->ParseContextLast 
      = (ps->ParseContextLast + PARSE_CONTEXT_SIZE - 1) % PARSE_CONTEXT_SIZE;
    if (ps->npush >= PUSHBACK_BUFSIZE) abort();
    ps->pushback[ps->npush++] = c;
}


/* --------------------------------------------------------------------------
   SOURCE REFERENCE ROUTINES
*/

static SEXP makeSrcref(source_location *lloc, SEXP srcfile)
{
    SEXP val;

    PROTECT(val = allocVector(INTSXP, 8));
    INTEGER(val)[0] = lloc->first_line;
    INTEGER(val)[1] = lloc->first_byte;
    INTEGER(val)[2] = lloc->last_line;
    INTEGER(val)[3] = lloc->last_byte;
    INTEGER(val)[4] = lloc->first_column;
    INTEGER(val)[5] = lloc->last_column;
    INTEGER(val)[6] = lloc->first_parsed;
    INTEGER(val)[7] = lloc->last_parsed;
    setAttrib(val, R_SrcfileSymbol, srcfile);
    setAttrib(val, R_ClassSymbol, mkString("srcref"));
    UNPROTECT(1);
    return val;
}

static void attachSrcrefs(SEXP val, SEXP t)
{
    SEXP srval;
    int n;

    PROTECT2(val,t);
    PROTECT(srval = allocVector(VECSXP, length(t)));

    for (n = 0 ; n < LENGTH(srval) ; n++, t = CDR(t))
	SET_VECTOR_ELT(srval, n, CAR(t));
    setAttrib(val, R_SrcrefSymbol, srval);
    setAttrib(val, R_SrcfileSymbol, ps->sr->SrcFile);

    source_location wholeFile;
    wholeFile.first_line = 1;
    wholeFile.first_byte = 0;
    wholeFile.first_column = 0;
    wholeFile.last_line = ps->sr->xxlineno;
    wholeFile.last_byte = ps->sr->xxbyteno;
    wholeFile.last_column = ps->sr->xxcolno;
    wholeFile.first_parsed = 1;
    wholeFile.last_parsed = ps->sr->xxparseno;
    setAttrib(val, R_WholeSrcrefSymbol, 
                   makeSrcref(&wholeFile, ps->sr->SrcFile));

    UNPROTECT(3);

    ps->sr->didAttach = TRUE;
}

void R_InitSrcRefState (SrcRefState *state, int keepSource)
{
    state->keepSrcRefs = keepSource;
    state->didAttach = FALSE;

    if (keepSource) {
        PROTECT_WITH_INDEX (state->SrcFile =
                             NewEnvironment(R_NilValue, R_NilValue, R_EmptyEnv),
                            &state->SrcFileProt);
        PROTECT_WITH_INDEX (state->Original = state->SrcFile, 
                            &state->OriginalProt);
    }
    else {
        PROTECT_WITH_INDEX (state->SrcFile = R_NilValue, &state->SrcFileProt);
        PROTECT_WITH_INDEX (state->Original = R_NilValue, &state->OriginalProt);
    }

    state->xxlineno = 1;
    state->xxcolno = 0;
    state->xxbyteno = 0;
    state->xxparseno = 1;

    PROTECT_WITH_INDEX (state->ParseData = R_NilValue, &state->ParseDataProt);
    state->containing_parse_rec = R_NilValue;
    state->unattached_comment_id = 0;
    state->next_id = 1;

    /* Here, we establish a place where the value of a token is protected. */

    PROTECT_WITH_INDEX (R_NilValue, &state->TokenValProt);
}

void R_TextForSrcRefState (SrcRefState *state, const char *text)
{
    if (state->didAttach) {
        SEXP filename_install = install("filename");  /* protected by the */
        SEXP lines_install = install("lines");        /*   symbol table   */
        SEXP class;
        set_var_in_frame (filename_install, ScalarString(mkChar("")),
                          state->Original, TRUE, 3);
        set_var_in_frame (lines_install, ScalarString(mkChar(text)),
                          state->Original, TRUE, 3);

        PROTECT(class = allocVector(STRSXP, 2));
        SET_STRING_ELT(class, 0, mkChar("srcfilecopy"));
        SET_STRING_ELT(class, 1, mkChar("srcfile"));
        setAttrib(state->Original, R_ClassSymbol, class);
        UNPROTECT(1);
    }
}

void R_FinalizeSrcRefState (SrcRefState *state)
{
    /* Convert parse data to final form. */

    int pdlen;
    SEXP p;

    pdlen = 0;
    for (p = state->ParseData; p!=R_NilValue; p = VECTOR_ELT(p,PDATA_REC_LINK))
        pdlen += 1;

    if (pdlen > 0 && isEnvironment(state->SrcFile)) {

        SEXP dims, mat, tokens, text, pdat, idat;
        int i, j, k;

        PROTECT (dims = allocVector (INTSXP, 2));
        INTEGER(dims)[0] = PDATA_ROWS;
        INTEGER(dims)[1] = pdlen;

        PROTECT (mat = allocVector (INTSXP, PDATA_ROWS*pdlen));

        PROTECT (tokens = allocVector (STRSXP, pdlen));
        PROTECT (text = allocVector (STRSXP, pdlen));

        pdat = state->ParseData;
        k = pdlen * PDATA_ROWS;
        for (i = pdlen-1; i >= 0; i--) {
            idat = VECTOR_ELT(pdat,PDATA_REC_IDATA);
            for (j = PDATA_ROWS-1; j >= 0; j--)
                INTEGER(mat)[--k] = INTEGER(idat)[j];
            SET_STRING_ELT (tokens, i, VECTOR_ELT(pdat,PDATA_REC_TOKEN));
            SET_STRING_ELT (text, i, VECTOR_ELT(pdat,PDATA_REC_TEXT));
            pdat = VECTOR_ELT(pdat,PDATA_REC_LINK);
        }

        setAttrib (mat, install("dim"), dims);
        setAttrib (mat, install("tokens"), tokens);
        setAttrib (mat, install("text"), text);
        setAttrib (mat, R_ClassSymbol, mkString("parseData"));

        set_var_in_frame (install("parseData"), mat, state->SrcFile, TRUE, 3);

        UNPROTECT(4); /* text, tokens, mat, dims */
    }

    /* We could just do an UNPROTECT(4), but this might detect some bugs... */

    UNPROTECT(1);
    if (R_PPStackTop != state->TokenValProt) abort();
    UNPROTECT(1);
    if (R_PPStackTop != state->ParseDataProt) abort();
    UNPROTECT(1);
    if (R_PPStackTop != state->OriginalProt) abort();
    UNPROTECT(1);
    if (R_PPStackTop != state->SrcFileProt) abort();

    state->containing_parse_rec = R_NilValue;  /* just in case... */
    state->ParseData = R_NilValue;
    state->Original = R_NilValue;
    state->SrcFile = R_NilValue;
}


/* --------------------------------------------------------------------------
   VARIABLES, MACROS, AND FUNCTIONS SUPPORTING THE PARSER

   The parser operates by recursive descent, with parsing decisions made
   by examining a lookahead token, which is in ps->next_token, though
   it's normally accessed by the NEXT_TOKEN macro. */


/* Begin a recursive-descent parsing routine.  Sets up for PROTECT_N. 
   Sets bgn_token_rec to the parse data record of the most recently
   obtained token (or to R_NilValue if source isn't kept). */

#define BGN_PARSE_FUN \
    NEXT_TOKEN;  /* so location and bgn_token_rec will be correct */ \
    SEXP bgn_token_rec = prev_token_rec(1); \
    int nprotect = 0;


/* End a recursive-descent parsing routine.  Unprotects everything that
   was protected with PROTECT_N.  Allows for exitting with R_NoObject result
   on an error. */

#define END_PARSE_FUN \
  end: \
    UNPROTECT(nprotect); \
    goto finish; \
  error: \
    UNPROTECT(nprotect); \
    return R_NoObject; \
  finish:


/* Parse a sub-expression (or other construct), with the call given as
   its argument.  Protects the result, which will normally be assigned
   to a local variable (in the argument).  If the sub-expression parse
   produced an error, this parse routine is exitted as well. */

#define PARSE_SUB(w) \
    do { \
        SEXP _sub_ = (w); \
        if (_sub_ == R_NoObject) goto error; \
        PROTECT_N(_sub_); \
    } while (0)

/* Version that doesn't protect. */

#define PARSE_SUB_NO_PROTECT(w) \
    do { \
        SEXP _sub_ = (w); \
        if (_sub_ == R_NoObject) goto error; \
    } while (0)


/* Produce an error message and exit parsing (up to the top level). */

#define PARSE_ERROR_MSG(s) \
    do { \
        error_msg(s); \
        goto error; \
    } while (0)

static void error_msg(const char *s)
{
    static char const unexpected[] = "unexpected ";

    R_ParseError     = ps->token_loc.first_line;
    R_ParseErrorCol  = ps->token_loc.first_column;
    R_ParseErrorFile = ps->sr->SrcFile;

    if (strcmp(s,unexpected) == 0) {
        if (ps->next_token < 256) {
            char t[4] = { '\'', ps->next_token, '\'', 0 };
            sprintf (R_ParseErrorMsg, _("unexpected %s"), t);
        }
        else if (ps->next_token-256 < NUM_TRANSLATED)
            sprintf (R_ParseErrorMsg, _("unexpected %s"),
                                      _(token_name[ps->next_token-256]));
        else
            sprintf (R_ParseErrorMsg, _("unexpected %s"),
                                      token_name[ps->next_token-256]);
    }
    else
        copy_1_string(R_ParseErrorMsg, sizeof R_ParseErrorMsg, s);

    R_ParseErrorMsg [(sizeof R_ParseErrorMsg) - 1] = 0; /* just in case */
}


/* Produce an error message saying the current token is unexpected, and
   exit to top level.  The token name is filled in by error_msg, based
   on the current value of next_token. */

#define PARSE_UNEXPECTED() PARSE_ERROR_MSG("unexpected ");


/* Say the current token is unexpected unless it is equal to tk. */

#define EXPECT(tk) \
    do { \
        if (NEXT_TOKEN != (tk)) \
            PARSE_UNEXPECTED(); \
        get_next_token(0); \
    } while (0)


/* Version of EXPECT that scans the next token with no_sym_un set. */

#define EXPECT_NO_SYMBOL_AFTER(tk) \
    do { \
        if (NEXT_TOKEN != (tk)) \
            PARSE_UNEXPECTED(); \
        get_next_token(1); \
    } while (0)


/* Protect a SEXP used in a parse routine from garbage collection. */

#define PROTECT_N(w) (nprotect += 1, PROTECT(w))

/* Unprotect the last k items protected with PROTECT_N.  Needed only
   if otherwise there might be too much on the protect stack. */

#define UNPROTECT_N(k) do { UNPROTECT(k); nprotect -= (k); } while (0)


/* Look at the next token, which will usually already be in ps->next_token.
   However, if next_token is '\n', advance to the next other token first. */

#define NEXT_TOKEN \
  (ps->next_token == '\n' ? get_next_token_not_newline() : ps->next_token) 

static int get_next_token_not_newline(void)
{
    do { 
        get_next_token(0); 
    } while (ps->next_token == '\n');

    ps->newline_before_token = 1;

    return ps->next_token;
}


/* Get the SEXP value associated with next_token, protecting it. */

#define TOKEN_VALUE() (PROTECT_N(ps->next_token_val))


/* Check whether the current expression is ended by a newline, based on
   the 'flags' and 'newline_before_token' variables. */

#define NL_END ((flags & END_ON_NL) && ps->newline_before_token)


/* Save the start location of next_token as the start of a region of
   the source text. */

static void start_location (source_location *loc)
{
    loc->first_line   = loc->last_line   = ps->token_loc.first_line;
    loc->first_column = loc->last_column = ps->token_loc.first_column;
    loc->first_byte   = loc->last_byte   = ps->token_loc.first_byte;
    loc->first_parsed = loc->last_parsed = ps->token_loc.first_parsed;
}


/* Save the end location of the previous token as the end of a region
   of source text. */

static void end_location (source_location *loc)
{
    loc->last_line   = ps->prev_token_loc.last_line;
    loc->last_column = ps->prev_token_loc.last_column;
    loc->last_byte   = ps->prev_token_loc.last_byte;
    loc->last_parsed = ps->prev_token_loc.last_parsed;
}


/* Tables of operator precedence.  The lower two bits are 1 for binary
   operators that are left associative, 2 for binary operators that are
   right associative, and 0 for relational operators, .., unary operators,
   and miscellaneous operators.  This is expressed in the NON_ASSOC, 
   LEFT_ASSOC, and RIGHT_ASSOC macros in Parse.h. */

static struct { SEXP *sym_ptr; int prec; } unary_prec_tbl[] =
{
    { &R_AddSymbol,               /* +   */ 0xc8 },
    { &R_SubSymbol,               /* -   */ 0xc8 },
    { &R_NotSymbol,               /* !   */ 0x78 },
    { &R_TildeSymbol,             /* ~   */ 0x58 },
    { &R_QuerySymbol,             /* ?   */ 0x28 },
    { 0, 0 }
};

static struct { SEXP *sym_ptr; int prec; } binary_prec_tbl[] =
{
    { &R_DoubleColonSymbol,       /* ::  */ 0xf0 },
    { &R_TripleColonSymbol,       /* ::: */ 0xf0 },
    { &R_ExptSymbol,              /* ^   */ 0xd2 },
    { &R_Expt2Symbol,             /* **  */ 0xd2 },
    { &R_ColonSymbol,             /* :   */ 0xc1 },
#   define SPECIAL_PREC           /* %x% */ 0xb1
    { &R_MulSymbol,               /* *   */ 0xa1 },
    { &R_DivSymbol,               /* /   */ 0xa1 },
    { &R_AddSymbol,               /* +   */ 0x91 },
    { &R_SubSymbol,               /* -   */ 0x91 },
    { &R_DotDotSymbol,            /* ..  */ 0x88 },
    { &R_NotSymbol,               /* !   */ 0x85 },
    { &R_BangBangSymbol,          /* !!  */ 0x85 },
    { &R_EqSymbol,                /* ==  */ 0x80 },
    { &R_NeSymbol,                /* !=  */ 0x80 },
    { &R_LtSymbol,                /* <   */ 0x80 },
    { &R_LeSymbol,                /* <=  */ 0x80 },
    { &R_GeSymbol,                /* >=  */ 0x80 },
    { &R_GtSymbol,                /* >   */ 0x80 },
    { &R_AndSymbol,               /* &   */ 0x71 },
    { &R_And2Symbol,              /* &&  */ 0x71 },
    { &R_OrSymbol,                /* |   */ 0x61 },
    { &R_Or2Symbol,               /* ||  */ 0x61 },
    { &R_TildeSymbol,             /* ~   */ 0x51 },
    { &R_LocalRightAssignSymbol,  /* ->  */ 0x41 },
    { &R_GlobalRightAssignSymbol, /* ->> */ 0x41 },
    { &R_LocalAssignSymbol,       /* <-  */ 0x32 },
    { &R_GlobalAssignSymbol,      /* <<- */ 0x32 },
    { &R_ColonAssignSymbol,       /* :=  */ 0x32 },
    { &R_QuerySymbol,             /* ?   */ 0x21 },
    { &R_EqAssignSymbol,          /* =   */ 0x12 },
    { 0, 0 }
#   define EQASSIGN_PREC 0x12
};

static struct { SEXP *sym_ptr; int prec; } misc_prec_tbl[] =
{
    { &R_BracketSymbol,           /* [   */ 0xe8 },
    { &R_Bracket2Symbol,          /* [[  */ 0xe8 },
    { &R_DollarSymbol,            /* $   */ 0xe8 },
    { &R_AtSymbol,                /* @   */ 0xe8 },

    { &R_FunctionSymbol,          /*     */ 0x08 },
    { &R_IfSymbol,                /*     */ 0x08 },
    { &R_WhileSymbol,             /*     */ 0x08 },
    { &R_RepeatSymbol,            /*     */ 0x08 },

    { 0, 0 }
};


/* Return the unary precedence of an operator symbol, or 0 if the 
   symbol is not a unary operator. */

attribute_hidden int unary_prec (SEXP sym)
{
    int i;

    for (i = 0; unary_prec_tbl[i].prec != 0; i++) {
        if (sym == *unary_prec_tbl[i].sym_ptr)
            return unary_prec_tbl[i].prec;
    }

    return 0;
}


/* Return the binary precedence of an operator symbol, or 0 if the 
   symbol is not a binary operator. */

attribute_hidden int binary_prec (SEXP sym)
{
    int i;

    for (i = 0; binary_prec_tbl[i].prec != 0; i++) {
        if (sym == *binary_prec_tbl[i].sym_ptr)
            return binary_prec_tbl[i].prec;
    }

    if (TYPEOF(sym) == SYMSXP) {
        const char *s = CHAR(PRINTNAME(sym));
        if (s[0] == '%') {
            for (i = 1; s[i] != 0; i++) {
               if (s[i] == '%')
                   return s[i+1] == 0 ? SPECIAL_PREC : 0;
            }
        }
    }

    return 0;
}


/* Return the precedence of a miscellaneous operator symbol, or 0 if the 
   symbol is not a miscellaneous operator. */

attribute_hidden int misc_prec (SEXP sym)
{
    int i;

    for (i = 0; misc_prec_tbl[i].prec != 0; i++) {
        if (sym == *misc_prec_tbl[i].sym_ptr)
            return misc_prec_tbl[i].prec;
    }

    return 0;
}
   

/* Return 0 if NEXT_TOKEN is not a unary operator, and otherwise
   the precedence of the unary operator. */

static int unary_op(void)
{
    SEXP sym;

    /* Operators must be special tokens, not symbols like `+`. */

    if (NEXT_TOKEN == SYMBOL)
        return 0;

    /* A symbol corresponding to an operator will be in next_token_val.
       We don't use TOKEN_VALUE below, since we don't want a PROTECT. */

    sym = ps->next_token_val;
    if (TYPEOF(sym) != SYMSXP)
        return 0;

    /* Return the unary precedence of the symbol, or 0 if not a unary op. */

    return unary_prec (sym);
}


/* Return 0 if NEXT_TOKEN is not a binary operator, and otherwise
   the precedence of the binary operator. */

static int binary_op(void)
{
    SEXP sym;

    /* The special binary operators of the form %xxx% are handled specially
       here (though they could instead be passed on to binary_prec). */

    if (NEXT_TOKEN == SPECIAL)
        return SPECIAL_PREC;

    /* Operators must be special tokens, not symbols like `+`. */

    if (NEXT_TOKEN == SYMBOL)
        return 0;

    /* A symbol corresponding to an operator will be in next_token_val.
       We don't use TOKEN_VALUE below, since we don't want a PROTECT. */

    sym = ps->next_token_val;
    if (TYPEOF(sym) != SYMSXP)
        return 0;

    /* Return the binary precedence of the symbol, or 0 if not a binary op. */

    return binary_prec (sym);
}


/* Macros to create language pairlists in which the last CONS cell (and its
   CAR) may be a shared constant.  Note that unlike lang2, lang3, and lang4,
   the arguments must be protected by the caller. */

#define LANG2(y,z) LCONS((y),MaybeConstList1(z))
#define LANG3(x,y,z) LCONS((x),CONS((y),MaybeConstList1(z)))
#define LANG4(w,x,y,z) LCONS((w),CONS((x),CONS((y),MaybeConstList1(z))))



/* --------------------------------------------------------------------------
   THE RECURSIVE DESCENT PARSER

   Each parse routine takes an int flags argument, whose bits have
   the meanings defined below.  

   The parse_expr routine also has a 'paren' argument for controlling
   how parentheses are handled.  If 'paren' is NULL, it is ignored,
   and no check regarding parentheses is done.  If 'paren' is not
   NULL, the int that it points to is set to 0 if the expression is
   not a parenthesized expression, or if the expression inside the
   parentheses is not one with a unary, binary, or relational
   operator.  If the expression is a parenthesized unary, binary, or
   relational operator, *paren is set to the precedence of the
   operator.  This allows the caller to decide whether to remove the
   parentheses if they are necessary (and hence will be re-inserted
   when the expression is deparsed).

   The parse routines return the object parsed, or R_NoObject if there
   was an error (except that some errors will cause an exit out of the
   whole parser with a call of "error").

   Maintainence of a lookahead token is complicated by the need for
   care in handling newlines.  A newline is sometimes a "soft EOF".
   For example, during interactive input, a newline after "f(x)" or
   "if (a<1) a <- 0" indicates the end of the expression, which is
   then evaluated.  But in other cases, such as within curly braces,
   newlines do not indicate the end of input, but only the end of a
   sub-expression.  This issue is handled by usually, but not always,
   automatically advancing past a newline to the next non-newline
   token, and by recording whether a newline preceeded the current
   token (so lookahead to the next non-newline token doesn't loose 
   this information).  The NEXT_TOKEN macro handles this automatic
   advancement, while the END_NL macro can test for newline ending
   an expression without forcing the read of a token following the
   newline (which in an interactive context would force user input).

   Source references are attached if ps->keep_source is non-zero. */


static SEXP parse_expr (int prec, int flags, int *paren);


/* Bits in the flags word passed to parsing routines. */

#define KEEP_PARENS (1<<0)  /* Keep parens in this or inner expressions */
#define END_ON_NL   (1<<1)  /* End expression when newline seen */
#define NO_PEEKING  (1<<2)  /* Don't look ahead for ELSE after newline
                               (only relevant when END_ON_NL set) */


/* Parse the formals list of a function definiton. */

static SEXP parse_formlist (int flags)
{
    BGN_PARSE_FUN;
    SEXP res;

    int subflags = flags &  ~ (END_ON_NL | NO_PEEKING);

    res = R_NilValue;
    if (NEXT_TOKEN != ')') {
        SEXP last;
        res = PROTECT_N (CONS(R_MissingArg,R_NilValue));
        last = res;
        for (;;) {
            SEXP tag, f;
            if (NEXT_TOKEN != SYMBOL)
                PARSE_UNEXPECTED();
            set_token_in_rec (prev_token_rec(1), "SYMBOL_FORMALS");
            tag = TOKEN_VALUE();
            for (f = res; f != R_NilValue; f = CDR(f)) {
                if (TAG(f) == tag) {
                    source_location loc;
                    start_location(&loc);
                    error(_("Repeated formal argument '%s' on line %d"), 
                            CHAR(PRINTNAME(tag)), loc.first_line);
                }
            }
            SET_TAG (last, tag);
            get_next_token(0);
            if (NEXT_TOKEN == EQ_ASSIGN) {
                SEXP def;
                set_token_in_rec (prev_token_rec(1), "EQ_FORMALS");
                get_next_token(0);
                PARSE_SUB(def = parse_expr (EQASSIGN_PREC, subflags, NULL));
                SETCAR (last, def);
            }
            if (NEXT_TOKEN != ',')
                break;
            get_next_token(0);
            SETCDR (last, CONS(R_MissingArg,R_NilValue));
            last = CDR(last);
        }
    }

    END_PARSE_FUN;
    return res;
}


/* Parse a list of subscripts or of function arguments.  An attempt is 
   made to make the last part of the list be a constant object.  Note
   that NULL is allowed as a tag (converted to `NULL`), presumably for 
   compatibility, though it's not allowed for a formal name.  Strings
   are also allowed for tags, though again they aren't for formal names. */

static SEXP parse_sublist (int flags)
{
    BGN_PARSE_FUN;
    int keep_parens = flags & KEEP_PARENS;
    SEXP res, last, last2;
    int ipar;

    int subflags = flags &  ~ (END_ON_NL | NO_PEEKING);

    res = R_NilValue;
    if (NEXT_TOKEN != ')') { /* check only ')', not ']':  [] has missing arg */

        SEXP next;

        for (;;) {

            if (NEXT_TOKEN == ',' || NEXT_TOKEN == ')' || NEXT_TOKEN == ']') 
                next = MaybeConstList1(R_MissingArg);
            else if (NEXT_TOKEN == '_') {
                next = MaybeConstList1(R_MissingUnder);
                get_next_token(0);
                if (NEXT_TOKEN != ',' && NEXT_TOKEN != ')' && NEXT_TOKEN != ']')
                    PARSE_UNEXPECTED();
            }
            else {
                SEXP arg;
                /* Avoid protecting too many things... Could be many args. */
                PARSE_SUB_NO_PROTECT (arg = 
                  parse_expr (EQASSIGN_PREC, subflags, &ipar));
                PROTECT_N(arg);

                if (NEXT_TOKEN == EQ_ASSIGN) {
                    SEXP tag, val;
                    set_token_in_rec (prev_token_rec(1), "EQ_SUB");
                    if (TYPEOF(arg) == SYMSXP) {
                        tag = arg;
                        set_token_in_rec (prev_token_rec(2), "SYMBOL_SUB");
                    }
                    else if (TYPEOF(arg) == STRSXP)
                        tag = install_translated (STRING_ELT(arg,0));
                    else if (arg == R_NilValue)
                        tag = install("NULL");
                    else
                        PARSE_UNEXPECTED();
                    delete_second_parseData_record();
                    get_next_token(0);
                    if (NEXT_TOKEN == ',' || NEXT_TOKEN == ')' 
                                          || NEXT_TOKEN == ']')
                        val = R_MissingArg;
                    else if (NEXT_TOKEN == '_') {
                        next = val = R_MissingUnder;
                        get_next_token(0);
                        if (NEXT_TOKEN != ',' && NEXT_TOKEN != ')' 
                                              && NEXT_TOKEN != ']')
                            PARSE_UNEXPECTED();
                    }
                    else {
                        /* Don't protect until end of parse_sublist, since 
                           that could lead to too many being protected. */
                        PARSE_SUB_NO_PROTECT (val = 
                          parse_expr (EQASSIGN_PREC, subflags, &ipar));
                        if (!keep_parens && ipar && needsparens_arg(CADR(val)))
                            val = CADR(val);  /* get rid of parens */
                    }
                    next = cons_with_tag(val,R_NilValue,tag);
                }
                else {
                    if (!keep_parens && ipar && needsparens_arg(CADR(arg)))
                        arg = CADR(arg);  /* get rid of parens */
                    next = MaybeConstList1(arg);
                }

                UNPROTECT_N(1); /* arg */
            }

            /* Beware: 'next' may not be protected at this point. */

            if (res == R_NilValue) {
                res = PROTECT_N (next);
                last = res;
                last2 = R_NilValue;
            }
            else {
                if (IS_CONSTANT(last)) {
                    PROTECT(next);
                    last = cons_with_tag(CAR(last),CDR(last),TAG(last));
                    UNPROTECT(1);
                    if (last2 == R_NilValue)
                        res = PROTECT_N (last);
                    else
                        SETCDR(last2,last);
                }
                SETCDR(last,next);
                last2 = last;
                last = next;
            }

            if (NEXT_TOKEN != ',')
                break;

            get_next_token(0);
        }
    }

    END_PARSE_FUN;
    return res;
}


/* Parse an expression in which any non-enclosed operator has precedence 
   greater than prec.  

   An expression - for instance, abc[i]/2+1 - is seen as being formed
   from an initial part - in this example, abc - zero or more postfix
   parts - in this example, [i] - which form a unit that is then possibly 
   contained in one or more binary operators - in this example, / and +.
   An expression starting with a unary operator will have the unary
   operator expression as its initial part (and there will be no possibility
   of a postfix part, since any such will have been absorbed into the 
   operand of the unary operator).  

   The 'paren' argument points to where to store an indicator of whether
   the parsed expression is parenthesized.  Note that (x) is considered to
   be parenthesized, but `(`(x) is not, even though they produce the same
   expression. If 'paren' is the C NULL pointer, this information isn't stored.

   The token after the expression is scanned with no_sym_un set to 1,
   since symbols and unary operators are not allowed in that context,
   and we wish the .. and !! operators to be recognized.

   An attempt is made to make the last operand of an operator be a constant
   object. */

static SEXP parse_expr (int prec, int flags, int *paren)
{
    BGN_PARSE_FUN;

    SEXP inner_rec = bgn_token_rec;
    SEXP rec, res, right, op;
    int op_prec, next_op_prec, ipar;
    source_location begin_loc, loc;

    int keep_parens = flags & KEEP_PARENS;
    int subflags = flags &  ~ (END_ON_NL | NO_PEEKING);
    int location_set = 0;  /* has location for end of expr already been set? */
    int par = 0;  /* parenthesization indicator - initially not parenthesized */

    start_location (&begin_loc);
    rec = start_parseData_record (&begin_loc, "expr", "", FALSE);
    set_parent_in_rec (inner_rec, rec);

    /* Unary operators. */

    if (op_prec = unary_op()) {
        op = TOKEN_VALUE();
        get_next_token(0);
        PARSE_SUB (res = parse_expr (op_prec, 
                           op == R_TildeSymbol ? flags|KEEP_PARENS : flags,
                           &ipar));
        if (!keep_parens && ipar && needsparens_unary(op,CADR(res)))
            res = CADR(res);  /* get rid of parens */
        res = PROTECT_N (LANG2 (op, res));
    }

    /* Symbols, string constants, namespace references built from
       one or the other or both of these, and gradient constructs. */

    else if (NEXT_TOKEN == SYMBOL || NEXT_TOKEN == STR_CONST) {

        SEXP op, sym;
        res = TOKEN_VALUE();
        get_next_token(1);  /* won't create parse data record for 'gradient' */

        /* Gradient constructs. */

        if (!NL_END && NEXT_TOKEN == SYMBOL && TYPEOF(res) == SYMSXP
                    && ps->next_token_val == R_GradientSymbol) {

            if (strcmp(CHAR(PRINTNAME(res)),"with") == 0
                 || strcmp(CHAR(PRINTNAME(res)),"track") == 0
                 || strcmp(CHAR(PRINTNAME(res)),"back") == 0
                 || strcmp(CHAR(PRINTNAME(res)),"compute") == 0) {

                char opname[20];
                strcpy(opname,CHAR(PRINTNAME(res)));
                strcat(opname," gradient");
                SEXP op = install(opname);

                enum token_type tk = 
                  strcmp(CHAR(PRINTNAME(res)),"with")  == 0 ? WITHGRAD :
                  strcmp(CHAR(PRINTNAME(res)),"track") == 0 ? TRACKGRAD :
                  strcmp(CHAR(PRINTNAME(res)),"back")  == 0 ? BACKGRAD :
                                                              COMPUTEGRAD;
                set_token_in_rec (prev_token_rec(1), pdata_token_name[tk-256]);
                set_text_in_rec (prev_token_rec(1), token_name[tk-256]);

                SEXP var, val, body, grad, last;
                get_next_token(0);

                PROTECT_N (res = last = LCONS (op, R_NilValue));

                EXPECT('(');
                int var_count = 0;
                for (;;) {
                    if (NEXT_TOKEN != SYMBOL)
                        PARSE_UNEXPECTED();
                    set_token_in_rec (prev_token_rec(1), "SYMBOL_FORMALS");
                    var = val = TOKEN_VALUE();
                    get_next_token(0);
                    if (NEXT_TOKEN == EQ_ASSIGN) {
                        set_token_in_rec (prev_token_rec(1), "EQ_FORMALS");
                        get_next_token(0);
                        PARSE_SUB(val = parse_expr 
                                         (EQASSIGN_PREC, subflags, NULL));
                    }
                    SETCDR (last, cons_with_tag (val, R_NilValue, var));
                    last = CDR(last);
                    var_count += 1;
                    if (NEXT_TOKEN != ',') break;
                    get_next_token(0);
                }
                EXPECT(')');

                PARSE_SUB(body = parse_expr (0, flags, NULL));
                SETCDR (last, CONS (body, R_NilValue));

                if (strcmp(opname,"compute gradient")==0) {

                    last = CDR(last);
                    if (NEXT_TOKEN != SYMBOL 
                          || ps->next_token_val != R_AsSymbol)
                        PARSE_UNEXPECTED();
                    get_next_token(0);

                    for (;;) {
                        PARSE_SUB(grad = parse_expr (0, flags, NULL));
                        SETCDR (last, CONS (grad, R_NilValue));
                        last = CDR(last);
                        var_count -= 1;
                        if (var_count == 0) break;
                        EXPECT(',');
                    }
                }
            }
        }

        /* Namespace references. */

        else if (!NL_END && (NEXT_TOKEN==NS_GET || NEXT_TOKEN==NS_GET_INT)) {
            op = TOKEN_VALUE();
            set_token_in_rec (prev_token_rec(2), "SYMBOL_PACKAGE");
            get_next_token(0);
            if (NEXT_TOKEN != SYMBOL && NEXT_TOKEN != STR_CONST)
                PARSE_UNEXPECTED();
            sym = TOKEN_VALUE();
            res = PROTECT_N (LANG3 (op, res, sym));
            get_next_token(1);
        }
    }

    /* Numeric, logical, and NULL constants. */

    else if (NEXT_TOKEN == NUM_CONST || NEXT_TOKEN == NULL_CONST) {
        res = TOKEN_VALUE();
        get_next_token(1);
    }

    /* Paren expressions.  Sets 'par' to 1 to indicate it's parenthesized. */

    else if (NEXT_TOKEN == '(') {
        SEXP op;
        op = TOKEN_VALUE();
        get_next_token(0);
        PARSE_SUB (res = parse_expr (0, subflags, NULL));
        res = PROTECT_N (LANG2 (op, res));
        EXPECT_NO_SYMBOL_AFTER(')');
        par = 1;
    }

    /* Curly expressions. */

    else if (NEXT_TOKEN == '{') {
        SEXP next, last, op, refs, last_ref;
        op = TOKEN_VALUE();
        res = PROTECT_N (LCONS(op,R_NilValue));
        start_location(&loc);
        get_next_token(0);
        end_location(&loc);
        if (ps->keep_source) {
            PROTECT_N (refs = CONS (makeSrcref(&loc,ps->sr->SrcFile),
                                    R_NilValue));
            last_ref = refs;
        }
        last = res;
        for (;;) {
            while (NEXT_TOKEN == ';')
                get_next_token(0);
            if (NEXT_TOKEN == '}')
                break;
            start_location(&loc);
            /* Avoid protecting too many things... */
            PARSE_SUB_NO_PROTECT (next = 
                                   parse_expr (0, subflags | END_ON_NL, NULL));
            PROTECT_N(next);
            end_location(&loc);
            if (ps->keep_source) {
                SETCDR (last_ref, CONS (makeSrcref(&loc,ps->sr->SrcFile),
                                        R_NilValue));
                last_ref = CDR(last_ref);
            }
            SETCDR (last, CONS(next,R_NilValue));
            last = CDR(last);
            UNPROTECT_N(1); /* next */
            if (!ps->newline_before_token && NEXT_TOKEN != ';' 
                                          && NEXT_TOKEN != '}')
                PARSE_UNEXPECTED();
        }
        if (ps->keep_source) {
            attachSrcrefs(res,refs);
        }
        get_next_token(1);
    }

    /* Function closures. */

    else if (NEXT_TOKEN == FUNCTION) {
        SEXP op, args, body, srcref;
        start_location(&loc);
        op = TOKEN_VALUE();
        get_next_token(0);
        EXPECT('(');
        PARSE_SUB(args = parse_formlist (flags));
        EXPECT(')');
        PARSE_SUB(body = parse_expr (0, flags, NULL));
        end_location(&loc);
        if (ps->keep_source) {
            srcref = makeSrcref(&loc, ps->sr->SrcFile);
            ps->sr->didAttach = TRUE;
        } 
        else
            srcref = R_NilValue;
        res = PROTECT_N (lang4 (op, args, body, srcref));
    }

    /* Repeat statements. */

    else if (NEXT_TOKEN == REPEAT) {
        SEXP op, body;
        op = TOKEN_VALUE();
        get_next_token(0);
        PARSE_SUB(body = parse_expr (0, flags, NULL));
        res = PROTECT_N (lang2 (op, body));
    }

    /* While statements. */

    else if (NEXT_TOKEN == WHILE) {
        SEXP op, cond, body;
        op = TOKEN_VALUE();
        get_next_token(0);
        EXPECT('(');
        PARSE_SUB(cond = parse_expr (EQASSIGN_PREC, subflags, &ipar));
        if (!keep_parens && ipar && needsparens_arg(CADR(cond)))
            cond = CADR(cond);  /* get rid of parens */
        EXPECT(')');
        PARSE_SUB(body = parse_expr (0, flags, NULL));
        res = PROTECT_N (lang3 (op, cond, body));
    }

    /* If statements. */

    else if (NEXT_TOKEN == IF) {

        SEXP op, cond, true_stmt, false_stmt;
        op = TOKEN_VALUE();
        get_next_token(0);
        EXPECT('(');
        PARSE_SUB(cond = parse_expr (EQASSIGN_PREC, subflags, &ipar));
        if (!keep_parens && ipar && needsparens_arg(CADR(cond)))
            cond = CADR(cond);  /* get rid of parens */
        EXPECT(')');
        PARSE_SUB(true_stmt = parse_expr(0, flags, &ipar));

        loc = begin_loc;      /* tentatively set location, in case there */
        end_location(&loc);   /*   is no 'else' */

        if ( ! (NL_END && (flags & NO_PEEKING)) && NEXT_TOKEN == ELSE) {
            if (!keep_parens && ipar) {
                SEXP e = CADR(true_stmt);
                if (TYPEOF(e)==LANGSXP && CAR(e)==R_IfSymbol && length(e)==3)
                    true_stmt = e;  /* get rid of parens */
            }
            get_next_token(0);
            PARSE_SUB(false_stmt = parse_expr (0, flags, NULL));
            res = PROTECT_N (LANG4 (op, cond, true_stmt, false_stmt));
        }
        else {
            res = PROTECT_N (LANG3 (op, cond, true_stmt));
            location_set = 1;  /* use tentative location set above */
        }
    }

    /* For statements. */

    else if (NEXT_TOKEN == FOR) {
        SEXP op, sym, vec, body, for_cond_rec, more_syms;
        int along = 0, across = 0, down = 0;
        source_location for_cond_loc;
        op = TOKEN_VALUE();
        get_next_token(0);
        NEXT_TOKEN;  /* force update of location */
        start_location (&for_cond_loc);
        for_cond_rec = 
          start_parseData_record (&for_cond_loc, "forcond", "", FALSE);
        set_parent_in_rec (prev_token_rec(1), for_cond_rec);
        EXPECT('(');
        if (NEXT_TOKEN != SYMBOL)
            PARSE_UNEXPECTED();
        sym = TOKEN_VALUE();
        get_next_token(0);
        more_syms = R_NilValue;
        while (NEXT_TOKEN == ',') {
            get_next_token(0);
            if (NEXT_TOKEN != SYMBOL)
                PARSE_UNEXPECTED();
            if (ps->next_token_val == sym)
                PARSE_ERROR_MSG("repeated 'for' variable");
            for (SEXP s = more_syms; s != R_NilValue; s = CDR(s))
                if (ps->next_token_val == s)
                    PARSE_ERROR_MSG("repeated 'for' variable");
            PROTECT_N(more_syms = CONS(ps->next_token_val,more_syms));
            get_next_token(0);
        }
        if (NEXT_TOKEN == SYMBOL && ps->next_token_val == R_AlongSymbol) {
            along = 1;
            get_next_token(0);
        }
        else {
            if (more_syms != R_NilValue)
                PARSE_ERROR_MSG(
                  "multiple 'for' variables are only allowed with 'along'");
            if (NEXT_TOKEN == SYMBOL && ps->next_token_val==R_AcrossSymbol) {
                across = 1;
                get_next_token(0);
            }
            else if (NEXT_TOKEN == SYMBOL && ps->next_token_val==R_DownSymbol) {
                down = 1;
                get_next_token(0);
            }
            else
                EXPECT(IN);
        }
        PARSE_SUB(vec = parse_expr (EQASSIGN_PREC, subflags, &ipar));
        if (!keep_parens && ipar && needsparens_arg(CADR(vec)))
            vec = CADR(vec);  /* get rid of parens */
        EXPECT(')');
        end_location (&for_cond_loc);
        end_parseData_record (for_cond_rec, &for_cond_loc);
        PARSE_SUB(body = parse_expr (0, flags, NULL));
        res = CONS (vec, CONS(body,R_NilValue));
        if (along)
            SET_TAG (res, R_AlongSymbol);
        else if (across)
            SET_TAG (res, R_AcrossSymbol);
        else if (down)
            SET_TAG (res, R_DownSymbol);
        while (more_syms != R_NilValue) {
            res = CONS (CAR(more_syms), res);
            more_syms = CDR(more_syms);
        }
        res = PROTECT_N (LCONS (op, CONS(sym,res)));
    }

    /* Next and break statements. */

    else if (NEXT_TOKEN == NEXT || NEXT_TOKEN == BREAK) {
        SEXP op;
        op = TOKEN_VALUE();
        res = PROTECT_N (LCONS (op, R_NilValue));
        get_next_token(0);
    }

    else
        PARSE_UNEXPECTED();

    /* Now handle postfix parts, looping over all of them.  New parse data
       records are created for the 'expr' non-terminals that make up the
       expression (eg, a$x[1] has 'expr' records for a, a$x, and a$x[i]). */

    while (!NL_END && (NEXT_TOKEN=='(' || NEXT_TOKEN=='[' || NEXT_TOKEN==LBB
                         || NEXT_TOKEN=='$' || NEXT_TOKEN=='@')) {

        SEXP op = TOKEN_VALUE();

        /* See if necessary parentheses preceded the (first) postfix part.
           If so, the parentheses are eliminated (unless KEEP_PARENS is set).
           Note that par will be 0 for second and later postfix parts. 
           Note also that all postfix operators act the same way as [. */

        if (par && !keep_parens 
                && needsparens_postfix (R_BracketSymbol, CADR(res)))
            res = CADR(res);  /* get rid of parens */

        /* We need to create a new, outer, parse data record, since we
           now know that the one we created previously wasn't for the
           outermost expression. */

        end_location(&loc);
        end_parseData_record(rec,&loc);
        inner_rec = rec;

        rec = start_parseData_record(&begin_loc,"expr","",FALSE);
        set_parent_in_rec (inner_rec, rec);
        set_parent_in_rec (prev_token_rec(1), rec);

        /* Function call. */

        if (NEXT_TOKEN == '(') {
            SEXP subs;
            if (TYPEOF(res) == SYMSXP || TYPEOF(res) == LANGSXP &&
                                          (CAR(res) == R_DoubleColonSymbol || 
                                           CAR(res) == R_TripleColonSymbol)) {
                set_token_in_rec (prev_token_rec(2), "SYMBOL_FUNCTION_CALL");
            }
            get_next_token(0);
            PARSE_SUB(subs = parse_sublist(flags));
            if (isString(res))
                res = installChar(STRING_ELT(res,0));
            res = PROTECT_N (LCONS(res,subs));
            EXPECT_NO_SYMBOL_AFTER(')');
        }

        /* Subscripting with [. */

        else if (NEXT_TOKEN == '[') {
            SEXP subs;
            get_next_token(0);
            PARSE_SUB(subs = parse_sublist (flags));
            res = PROTECT_N (LCONS (op, CONS (res, subs)));
            EXPECT_NO_SYMBOL_AFTER(']');
        }

        /* Subscripting with [[. */

        else if (NEXT_TOKEN == LBB) {
            SEXP subs;
            get_next_token(0);
            PARSE_SUB(subs = parse_sublist (flags));
            res = PROTECT_N (LCONS (op, CONS (res, subs)));
            EXPECT(']');
            EXPECT_NO_SYMBOL_AFTER(']');
        }

        /* Subsetting with $. */

        else if (NEXT_TOKEN == '$') {
            SEXP sym;
            get_next_token(0);
            if (NEXT_TOKEN != SYMBOL && NEXT_TOKEN != STR_CONST)
                PARSE_UNEXPECTED();
            sym = TOKEN_VALUE();
            res = PROTECT_N (LANG3 (op, res, sym));
            get_next_token(1);
        }

        /* Slot access with @. */

        else if (NEXT_TOKEN == '@') {
            SEXP sym;
            get_next_token(0);
            if (NEXT_TOKEN != SYMBOL && NEXT_TOKEN != STR_CONST)
                PARSE_UNEXPECTED();
            if (NEXT_TOKEN == SYMBOL)
                set_token_in_rec (prev_token_rec(1), "SLOT");
            sym = TOKEN_VALUE();
            res = PROTECT_N (LANG3 (op, res, sym));
            get_next_token(1);
        }

        else
            abort();

        par = 0;  /* indicate that this is not a parenthesized expression */
    }

    /* Now handle binary operators following any of the above, absorbing
       all of them that we can given the precedence constraint.  New 
       parse data records are created as we discover that there are more
       subexpressions. */

    int last_prec = 0;

    while (!NL_END) {

        op_prec = binary_op();

        if (op_prec <= prec || op_prec == last_prec)
            break;

        op = TOKEN_VALUE();

        if (!keep_parens && par && needsparens_binary (op, CADR(res), TRUE))
            res = CADR(res);  /* get rid of parens */

        end_location(&loc);
        end_parseData_record(rec,&loc);
        inner_rec = rec;

        rec = start_parseData_record(&begin_loc,"expr","",FALSE);
        set_parent_in_rec (inner_rec, rec);
        set_parent_in_rec (prev_token_rec(1), rec);

        get_next_token(0);

        if (LEFT_ASSOC(op_prec)) {

            /* For left-associate operators, we loop over successive right
               operands.  For example, with a+b+c+d, we will call parse_expr
               three times in this loop to parse b, c, and d. */

            for (;;) {
                PARSE_SUB(right = parse_expr (op_prec, 
                            op == R_TildeSymbol ? flags|KEEP_PARENS : flags,
                            &ipar));
                if (!keep_parens && ipar 
                                 && needsparens_binary (op, CADR(right), FALSE))
                    right = CADR(right);  /* get rid of parens */
                res = PROTECT_N (LANG3 (op, res, right));
                if (NL_END || binary_op() != op_prec) 
                    break;
                op = TOKEN_VALUE();
                end_location(&loc);
                end_parseData_record(rec,&loc);
                inner_rec = rec;
                rec = start_parseData_record(&begin_loc,"expr","",FALSE);
                set_parent_in_rec (inner_rec, rec);
                set_parent_in_rec (prev_token_rec(1), rec);
                get_next_token(0);
            }
        }
        else {

            /* For right-associative and non-associative operators, a
               recursive call of parse_expr will absorb the whole right
               side.  For example, with a<-b<-c<-d, one call of parse_expr
               will parse b<-c<-d, and for a<b<c, the call will parse
               b only, leaving the second < to produce an error. */

            if (RIGHT_ASSOC(op_prec))
                PARSE_SUB(right = parse_expr (op_prec-1, flags, &ipar));
            else /* NON_ASSOC */
                PARSE_SUB(right = parse_expr (op_prec, flags, &ipar));

            if (!keep_parens && ipar 
                             && needsparens_binary (op, CADR(right), FALSE))
                right = CADR(right);  /* get rid of parens */
            res = PROTECT_N (LANG3 (op, res, right));
        }

        last_prec = op_prec;

        par = 0;  /* indicate that this is not a parenthesized expression */
    }

    if (paren != NULL) *paren = par;

    if (!location_set) {
        loc = begin_loc;
        end_location (&loc);
    }
    end_parseData_record (rec, &loc);
    if (ps->next_token != '\n' && ps->next_token != END_OF_INPUT)
        set_parent_in_rec (prev_token_rec(1), ps->sr->containing_parse_rec);

    location_last_expr = loc;

    END_PARSE_FUN;
    return res;
}


/* Top level parse function, parsing an expression (including assignment
   with '=') that is followed by ';', newline, or end of file. */

static SEXP parse_prog (int flags)
{
    BGN_PARSE_FUN;
    SEXP res;

    PARSE_SUB (res = parse_expr (0, flags, NULL));

    set_initial_comments_parent();
       
    if (!ps->newline_before_token && NEXT_TOKEN != ';')
        PARSE_UNEXPECTED();

    END_PARSE_FUN;
    return res;
}

/* -------------------------------------------------------------------------- 
   PARSING ENTRY POINTS.

   See the documentation at the start of this module. */


#define PARSE_INIT(sv) \
    struct parse_state new_parse_state; \
    void *saved = (sv); \
    ps = &new_parse_state; \
    if (saved) \
        memcpy (&new_parse_state, saved, sizeof (struct parse_state)); \
    else { \
        ps->next_token_val = R_NilValue; \
        ps->parse_dotdot = R_parse_dotdot; \
        ps->token_loc.first_line = 0; \
        ps->token_loc.first_column = 0; \
        ps->token_loc.first_byte = 0; \
        ps->token_loc.first_parsed = 1; \
        ps->ParseContext[0] = 0; \
        ps->ParseContextLast = 0; \
        ps->ParseContextLine = 0; \
        ps->prevpos = 0; \
        ps->npush = 0; \
    }

#define PARSE_FINI \
    memcpy (R_ParseContext, ps->ParseContext, PARSE_CONTEXT_SIZE); \
    R_ParseContextLast = ps->ParseContextLast; \
    R_ParseContextLine = ps->ParseContextLine;


/* Create top-level flags to pass to parse_prog.  The no_peeking argument
   should be TRUE if peeking ahead looking for an "else" is not allowed
   (as appropriate if input is from the user, interactively). */

static int prog_flags (int no_peeking)
{
    int flags;
    SEXP keepp;

    flags = END_ON_NL;
    if (no_peeking) flags |= NO_PEEKING;

    keepp = GetOption1(install("keep.parens"));
    if (TYPEOF(keepp) == LGLSXP && LOGICAL(keepp)[0] == 1)
        flags |= KEEP_PARENS;

    return flags;
}


static int call_stream_getc(void) 
{ 
    return (*ps->stream_getc)(ps->stream_getc_arg);
}


attribute_hidden SEXP R_Parse1Stream(int (*getc) (void *), void *getc_arg, 
                                     ParseStatus *status, SrcRefState *state,
                                     int no_peeking, int retain, char *saved_ps)
{
    PARSE_INIT(retain ? saved_ps : NULL)

    ps->stream_getc = getc;
    ps->stream_getc_arg = getc_arg;
    ps->ptr_getc = call_stream_getc;
    ps->sr = state;
    ps->keep_source = state->keepSrcRefs;

    SEXP res = R_NilValue;

    if (!retain || ps->next_token == '\n' || ps->next_token == ';') {
        ps->ParseContext[0] = 0;
        ps->ParseContextLast = 0;
        get_next_token(0);
    }

    if (ps->next_token == END_OF_INPUT)
        *status = PARSE_EOF;
    else if (ps->next_token == '\n' || ps->next_token == ';')
        *status = PARSE_NULL;
    else {
        res = parse_prog (prog_flags(no_peeking));
        if (res == R_NoObject) {
            res = R_NilValue;
            *status = PARSE_ERROR;
        }
        else
            *status = PARSE_OK;
    }

    if (saved_ps)
        memcpy (saved_ps, ps, sizeof (struct parse_state));

    PARSE_FINI

    return res;
}


static SEXP R_Parse(int n, ParseStatus *status, SEXP srcfile, int no_peeking)
{
    SEXP rval, tval, tlast, res, refs, last_ref;
    PROTECT_INDEX rval_prot;
    SrcRefState state;
    int i;

    /* We must make a place to protect rval before calling R_InitSrcRefState. */

    PROTECT_WITH_INDEX (rval = R_NilValue, &rval_prot);

    ps->sr = &state;
    R_InitSrcRefState (ps->sr, !isNull(srcfile) && !isString(srcfile));

    REPROTECT(ps->sr->SrcFile = srcfile, ps->sr->SrcFileProt);
    REPROTECT(ps->sr->Original = srcfile, ps->sr->OriginalProt);

    PROTECT(tval = CONS(R_NilValue,R_NilValue));
    tlast = tval;

    if (ps->sr->keepSrcRefs) {
        PROTECT(refs = CONS(R_NilValue,R_NilValue));
        last_ref = refs;
    }
    else
        PROTECT(refs = R_NilValue);
    
    ps->keep_source = ps->sr->keepSrcRefs;

    const int flags = prog_flags(no_peeking);

    i = 0;
    while (n < 0 || i < n) {

        rval = R_NilValue;

        if ((i == 0 || ps->next_token == '\n' || ps->next_token == ';'
                    || ps->next_token == END_OF_INPUT) && !get_next_token(0))
            goto finish;

        if (ps->next_token == '\n' || ps->next_token == ';'
                    || ps->next_token == END_OF_INPUT)
            continue;

        res = parse_prog (flags);

        if (res == R_NoObject) {
            *status = PARSE_ERROR;
            goto ret;
        }

        SETCDR (tlast, CONS (res, R_NilValue));
        tlast = CDR(tlast);
        if (ps->sr->keepSrcRefs) {
            SETCDR (last_ref, 
                    CONS (makeSrcref (&location_last_expr, ps->sr->SrcFile),
                          R_NilValue));
            last_ref = CDR(last_ref);
        }

        i += 1;
    }

finish:
    *status = PARSE_OK;
    tval = CDR(tval);
    REPROTECT (rval = allocVector(EXPRSXP, length(tval)), rval_prot);
    for (i = 0 ; i < LENGTH(rval) ; i++, tval = CDR(tval))
	SET_VECTOR_ELT(rval, i, CAR(tval));
    if (ps->sr->keepSrcRefs)
	attachSrcrefs(rval,CDR(refs));

ret:
    UNPROTECT(2); /* tval, refs - must unprotect before R_FinalizeSrcRefState */
    R_FinalizeSrcRefState(ps->sr);
    UNPROTECT(1); /* rval - must be unprotected after R_FinalizeSrcRefState */
    return rval;
}


static int text_getc(void) { return R_TextBufferGetc(ps->textb_ptr); }

SEXP R_ParseVector(SEXP text, int n, ParseStatus *status, SEXP srcfile)
{
    PARSE_INIT(0)

    SEXP rval;
    TextBuffer textb;

    PROTECT(text);
    R_TextBufferInit(&textb, text);
    UNPROTECT(1);

    ps->textb_ptr = &textb;
    ps->ptr_getc = text_getc;

    rval = R_Parse(n, status, srcfile, FALSE);

    R_TextBufferFree(&textb);

    PARSE_FINI

    return rval;
}


static int conn_getc (void) { return Rconn_fgetc (ps->conn); }

SEXP R_ParseConn (Rconnection con, int n, ParseStatus *status, SEXP srcfile)
{
    PARSE_INIT(0)

    SEXP res;

    ps->conn = con;
    ps->ptr_getc = conn_getc;

    res = R_Parse (n, status, srcfile, FALSE);

    PARSE_FINI

    return res;
}


SEXP R_ParseStream (int (*getc) (void *), void *getc_arg, 
                    int n, ParseStatus *status, SEXP srcfile)
{
    PARSE_INIT(0)

    SEXP res;

    ps->stream_getc = getc;
    ps->stream_getc_arg = getc_arg;
    ps->ptr_getc = call_stream_getc;

    res = R_Parse (n, status, srcfile, TRUE);

    PARSE_FINI

    return res;
}


/* --------------------------------------------------------------------------
   TEXT BUFFER

   This is used as the buffer for NumericValue, SpecialValue and
   SymbolValue.  None of these could conceivably need 8192 bytes.

   For inclusion in parse data, it is also used to store text from 
   strings, or a message saying the text was truncated, and text
   from comments that aren't very long. */

static char yytext[MAXELTSIZE];

#define DECLARE_YYTEXT_BUFP(bp) char *bp = yytext

#define YYTEXT_PUSH(c, bp) do { \
    if ((bp) - yytext >= sizeof(yytext) - 1) \
        error(_("input buffer overflow at line %d"), ps->sr->xxlineno); \
    *(bp)++ = (c); \
} while(0)

#define YYTEXT_UNPUSH(bp) ((bp) -= 1)


/* --------------------------------------------------------------------------
   ROUTINES FOR CREATING NUMERIC AND STRING VALUES
*/


static SEXP mkReal(const char *s)
{
    return ScalarRealMaybeConst(R_atof(s));
}


static SEXP mkInteger(const char *s)
{
    double f = R_atof(s);  /* or R_strtol? */
    return ScalarIntegerMaybeConst((int) f);
}


static SEXP mkComplex(const char *s)
{
    SEXP t = R_NilValue;
    double f;
    f = R_atof(s); /* FIXME: make certain the value is legitimate. */

    t = allocVector(CPLXSXP, 1);
    COMPLEX(t)[0].r = 0;
    COMPLEX(t)[0].i = f;

    return t;
}


static int NumericValue(int c)
{
    int seendot = (c == '.');
    int seenexp = 0;
    int last = c;
    int nd = 0;
    int count = 1; /* The number of characters seen */

    DECLARE_YYTEXT_BUFP(yyp);
    YYTEXT_PUSH(c, yyp);

    /* We don't care about other than ASCII digits */
    while (isdigit(c = xxgetc()) || c == '.' || c == 'e' || c == 'E'
	   || c == 'x' || c == 'X')
    {
	count++;

	if (c == 'x' || c == 'X') {
	    if (count > 2 || last != '0') break;  /* 0x must be first */
	    YYTEXT_PUSH(c, yyp);
	    while(isdigit(c = xxgetc()) || ('a' <= c && c <= 'f') ||
		  ('A' <= c && c <= 'F') || c == '.') {
                if (c == '.') {
                    if (seendot) {
                        if (*(yyp-1) == '.') {  /* we see ".."; stop before */
                            YYTEXT_UNPUSH(yyp);
                            xxungetc(c);
                            seendot = 0;
                            goto out;
                        }
                        else
                            return ERROR;
                    }
                    seendot = 1;
                }
		YYTEXT_PUSH(c, yyp);
		nd++;
	    }
	    if (nd == 0) return ERROR;
	    if (c == 'p' || c == 'P') {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
		if (!isdigit(c) && c != '+' && c != '-') return ERROR;
		if (c == '+' || c == '-') {
		    YYTEXT_PUSH(c, yyp);
		    c = xxgetc();
		}
		for(nd = 0; isdigit(c); c = xxgetc(), nd++)
		    YYTEXT_PUSH(c, yyp);
		if (nd == 0) return ERROR;
	    }
	    break;
	}

	if (c == 'E' || c == 'e') {
	    if (seenexp)
		break;
	    seenexp = 1;
	    seendot = seendot == 1 ? seendot : 2;
	    YYTEXT_PUSH(c, yyp);
	    c = xxgetc();
	    if (!isdigit(c) && c != '+' && c != '-') return ERROR;
	    if (c == '+' || c == '-') {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
		if (!isdigit(c)) return ERROR;
	    }
	}

	if (c == '.') {
	    if (seendot) {
                if (*(yyp-1) == '.') { /* we see ".."; stop before */
                    YYTEXT_UNPUSH(yyp);
                    xxungetc(c);
                    seendot = 0;
                }
		break;
            }
	    seendot = 1;
	}

	YYTEXT_PUSH(c, yyp);
	last = c;
    }

out:
    YYTEXT_PUSH('\0', yyp);

    if (c == 'L') {
	/* We are asked to create an integer via the L, so we check that the
	   double and int values are the same. If not, this is a problem and we
	   will not lose information and so use the numeric value.
	*/
	double a = R_atof(yytext);
	int b = (int) a;
	if(a != (double) b) {
            if(seendot == 1 && seenexp == 0)
		warning(
                _("integer literal %sL contains decimal; using numeric value"),
                yytext);
	    else
		warning(
                _("non-integer value %s qualified with L; using numeric value"),
                yytext);
            ps->next_token_val = mkReal(yytext);
	}
        else {
            if (seendot == 1 && seenexp == 0)
	        warning(
                _("integer literal %sL contains unnecessary decimal point"),
                yytext);
            ps->next_token_val = mkInteger(yytext);
        }
    }
    else if (c == 'i') {
	ps->next_token_val = mkComplex(yytext);
    }
    else {
        ps->next_token_val = mkReal(yytext);
        xxungetc(c);
    }

    if (c == 'i' || c == 'L') { /* include for getParseData */
        YYTEXT_UNPUSH(yyp);
        YYTEXT_PUSH(c, yyp);
        YYTEXT_PUSH('\0', yyp);
    }

    return NUM_CONST;
}


/* Gets a possibly multi-byte character whose first character is passed as c,
   with remaining ones gotten with xxgetc, but then backed out with xxungetc.
   
   Strings may contain the standard ANSI escapes and octal specifications of 
   the form \o, \oo or \ooo, where 'o' is an octal digit. 

   If a string contains \u escapes that are not valid in the current locale, 
   we should switch to UTF-8 for that string.  Needs Unicode wide-char support.
*/

static int mbcs_get_next(int c, wchar_t *wc)
{
    int i, res, clen = 1; char s[9];
    mbstate_t mb_st;

    s[0] = c;
    /* This assumes (probably OK) that all MBCS embed ASCII as single-byte
       lead bytes, including control chars */
    if((unsigned int) c < 0x80) {
	*wc = (wchar_t) c;
	return 1;
    }
    if(utf8locale) {
	clen = utf8clen(c);
	for(i = 1; i < clen; i++) {
	    int ch = xxgetc();
	    if (ch == R_EOF) 
                error(_("EOF whilst reading MBCS char at line %d"), 
                        ps->sr->xxlineno);
	    s[i] = ch;
	}
	s[clen] ='\0'; /* x86 Solaris requires this */
	res = mbrtowc(wc, s, clen, NULL);
	if(res < 0) 
            error(_("invalid multibyte character in parser at line %d"), 
                    ps->sr->xxlineno);
    } else {
	/* This is not necessarily correct for stateful MBCS */
	while(clen <= MB_CUR_MAX) {
	    mbs_init(&mb_st);
	    res = mbrtowc(wc, s, clen, &mb_st);
	    if(res >= 0) break;
	    if(res == -1)
		error(_("invalid multibyte character in parser at line %d"),
                         ps->sr->xxlineno);
	    /* so res == -2 */
	    c = xxgetc();
	    if(c == R_EOF)
                error(_("EOF whilst reading MBCS char at line %d"),
                         ps->sr->xxlineno);
	    s[clen++] = c;
	} /* we've tried enough, so must be complete or invalid by now */
    }
    for(i = clen - 1; i > 0; i--) xxungetc(s[i]);
    return clen;
}

#if defined(Win32) || defined(__STDC_ISO_10646__)

#define mbcs_get_next2 mbcs_get_next
typedef wchar_t ucs_t;

#else

#define WC_NOT_UNICODE 
typedef unsigned int ucs_t;

static int mbcs_get_next2(int c, ucs_t *wc)
{
    int i, res, clen = 1; char s[9];

    s[0] = c;
    /* This assumes (probably OK) that all MBCS embed ASCII as single-byte
       lead bytes, including control chars */
    if ((unsigned int) c < 0x80) {
	*wc = (wchar_t) c;
	return 1;
    }
    if(utf8locale) {
	clen = utf8clen(c);
	for(i = 1; i < clen; i++) {
	    int ch = xxgetc();
	    if (ch == R_EOF) 
	    if(s[i] == R_EOF)
                error(_("EOF whilst reading MBCS char at line %d"),
                         ps->sr->xxlineno);
	    s[i] = ch;
	}
	s[clen] ='\0'; /* x86 Solaris requires this */
	res = mbtoucs(wc, s, clen);
	if (res == -1) 
            error(_("invalid multibyte character in parser at line %d"),
                     ps->sr->xxlineno);
    } else {
	/* This is not necessarily correct for stateful MBCS */
	while(clen <= MB_CUR_MAX) {
	    res = mbtoucs(wc, s, clen);
	    if (res >= 0) break;
	    if (res == -1)
		error(_("invalid multibyte character in parser at line %d"),
                         ps->sr->xxlineno);
	    /* so res == -2 */
	    c = xxgetc();
	    if (c == R_EOF)
                error(_("EOF whilst reading MBCS char at line %d"),
                         ps->sr->xxlineno);
	    s[clen++] = c;
	} /* we've tried enough, so must be complete or invalid by now */
    }
    for(i = clen - 1; i > 0; i--) xxungetc(s[i]);
    return clen;
}

#endif


static SEXP mkStringUTF8(const ucs_t *wcs, int cnt)
{
    int nb;

/* NB: cnt includes the terminator */

#ifdef Win32
    nb = cnt*4; /* UCS-2/UTF-16 so max 4 bytes per wchar_t */
#else
    nb = cnt*6;
#endif
    char s[nb];
    R_CheckStack();
    memset(s, 0, nb); /* safety */

#ifdef WC_NOT_UNICODE
    {
	char *ss;
	for(ss = s; *wcs; wcs++) ss += ucstoutf8(ss, *wcs);
    }
#else
    wcstoutf8(s, wcs, nb);
#endif

    return ScalarStringMaybeConst (mkCharCE (s, CE_UTF8));
}


static SEXP mkString2(const char *s, int len, Rboolean escaped)
{
    cetype_t enc = CE_NATIVE;

    if(known_to_be_latin1) enc= CE_LATIN1;
    else if(!escaped && known_to_be_utf8) enc = CE_UTF8;

    return ScalarStringMaybeConst (mkCharLenCE (s, len, enc));
}


/* forSymbol is true when parsing backticked symbols */

static int StringValue(int c, Rboolean forSymbol)
{
    int quote = c;
    Rboolean oct_or_hex = FALSE, use_wcs = FALSE, currtext_truncated = FALSE;

    char st0[MAXELTSIZE];
    unsigned int nstext = MAXELTSIZE;
    char *stext = st0, *bp = st0;

#   define STEXT_PUSH(c) do {               \
	unsigned int nc = bp - stext;       \
	if (nc >= nstext - 1) {             \
	    char *old = stext;              \
	    nstext *= 2;                    \
	    stext = malloc(nstext);         \
	    if (!stext) {                   \
               if (old != st0) free(old);   \
               error(_("unable to allocate buffer for long string at line %d"),\
                     ps->sr->xxlineno); \
            }                               \
	    memmove(stext, old, nc);        \
	    if (old != st0) free(old);	    \
	    bp = stext+nc; }		    \
	*bp++ = (c);                        \
    } while(0)

    int wcnt = 0;
    ucs_t wcs[10001];

#   define WTEXT_PUSH(c) do { if(wcnt <= 10000) wcs[wcnt++] = c; } while(0)

    char currtext[1010], *ct = currtext;

#   define CTEXT_PUSH(c) do {                     \
	if (ct - currtext >= 1000) {              \
            memmove(currtext, currtext+100, 901); \
            memmove(currtext, "... ", 4);         \
            ct -= 100;                            \
	    currtext_truncated = TRUE;            \
        }                                         \
	*ct++ = (c);                              \
    } while(0)

#   define CTEXT_POP() (ct--)

    CTEXT_PUSH(c); /* push opening quote */
    while ((c = xxgetc()) != R_EOF && c != quote) {
	CTEXT_PUSH(c);
	if (c == '\n') {
	    xxungetc(c); CTEXT_POP();
	    /* Fix suggested by Mark Bravington to allow multiline strings
	     * by pretending we've seen a backslash. Was:
	     * return ERROR;
	     */
	    c = '\\';
	}
	if (c == '\\') {
	    c = xxgetc(); CTEXT_PUSH(c);
	    if ('0' <= c && c <= '7') {
		int octal = c - '0';
		if ('0' <= (c = xxgetc()) && c <= '7') {
		    CTEXT_PUSH(c);
		    octal = 8 * octal + c - '0';
		    if ('0' <= (c = xxgetc()) && c <= '7') {
			CTEXT_PUSH(c);
			octal = 8 * octal + c - '0';
		    } else
			xxungetc(c);
		} else
		    xxungetc(c);
		if (!octal) {
                    if (stext != st0) free(stext);
		    error(_("nul character not allowed (line %d)"), 
                          ps->sr->xxlineno);
                }
		c = octal;
		oct_or_hex = TRUE;
	    }
	    else if(c == 'x') {
		int val = 0; int i, ext;
		for(i = 0; i < 2; i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c); CTEXT_POP();
			if (i == 0) { /* was just \x */
			    *ct = '\0';
                            if (stext != st0) free(stext);
			    errorcall(R_NilValue, 
                             _("'\\x' used without hex digits in character string starting \"%s\""), 
                             currtext);
			}
			break;
		    }
		    val = 16*val + ext;
		}
		if (!val) {
                    if (stext != st0) free(stext);
		    error(_("nul character not allowed (line %d)"), 
                          ps->sr->xxlineno);
                }
		c = val;
		oct_or_hex = TRUE;
	    }
	    else if (c == 'u' || c == 'U') {
		unsigned int val = 0; int i, ext; 
		Rboolean delim = FALSE;
                int bigU = c == 'U';

		if(forSymbol) {
                    if (stext != st0) free(stext);
		    error (bigU ? _("\\Uxxxxxxxx sequences not supported inside backticks (line %d)")
                                : _("\\uxxxx sequences not supported inside backticks (line %d)"), 
                      ps->sr->xxlineno);
                }
		if((c = xxgetc()) == '{') {
		    delim = TRUE;
		    CTEXT_PUSH(c);
		}
                else
                    xxungetc(c);
		for (i = 0; i < (bigU ? 8 : 4); i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c); CTEXT_POP();
			if (i == 0) { /* was just \u or \U */
			    *ct = '\0';
                            if (stext != st0) free(stext);
			    errorcall (R_NilValue, 
                              bigU ? _("'\\U' used without hex digits in character string starting \"%s\"")
                                   : _("'\\u' used without hex digits in character string starting \"%s\""), 
                              currtext);
			}
			break;
		    }
		    val = 16*val + ext;
		}
		if(delim) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if (c != '}') {
                        if (stext != st0) free(stext);
			error (bigU ? _("invalid \\U{xxxxxxxx} sequence (line %d)")
                                    : _("invalid \\u{xxxx} sequence (line %d)"),
			      ps->sr->xxlineno);
                    }
		}
		if (!val) {
                    if (stext != st0) free(stext);
		    error(_("nul character not allowed (line %d)"),
                          ps->sr->xxlineno);
                }
		WTEXT_PUSH(val); /* this assumes wchar_t is Unicode */
		use_wcs = TRUE;
		continue;
	    }
	    else {
		switch (c) {
		case 'a':
		    c = '\a';
		    break;
		case 'b':
		    c = '\b';
		    break;
		case 'f':
		    c = '\f';
		    break;
		case 'n':
		    c = '\n';
		    break;
		case 'r':
		    c = '\r';
		    break;
		case 't':
		    c = '\t';
		    break;
		case 'v':
		    c = '\v';
		    break;
		case '\\':
		    c = '\\';
		    break;
		case '"':
		case '\'':
		case ' ':
		case '`':
		case '\n':
		    break;
		default:
		    *ct = '\0';
                    if (stext != st0) free(stext);
		    errorcall(R_NilValue, 
                       _("'\\%c' is an unrecognized escape in character string starting \"%s\""), 
                       c, currtext);
		}
	    }
	} else if(mbcslocale) {
	    int i, clen;
	    ucs_t wc;
	    clen = mbcs_get_next2(c, &wc);
	    WTEXT_PUSH(wc);
	    for(i = 0; i < clen - 1; i++){
		STEXT_PUSH(c);
		c = xxgetc();
		if (c == R_EOF) break;
		CTEXT_PUSH(c);
		if (c == '\n') {
		    xxungetc(c); CTEXT_POP();
		    c = '\\';
		}
	    }
	    if (c == R_EOF) break;
	    STEXT_PUSH(c);
	    continue;
	}
	STEXT_PUSH(c);
	if ((unsigned int) c < 0x80) WTEXT_PUSH(c);
	else { /* have an 8-bit char in the current encoding */
#           ifdef WC_NOT_UNICODE
	        ucs_t wc;
                char s[2] = " ";
                s[0] = c;
                mbtoucs(&wc, s, 2);
#           else
                wchar_t wc;
                char s[2] = " ";
                s[0] = c;
                mbrtowc(&wc, s, 2, NULL);
#           endif
	    WTEXT_PUSH(wc);
	}
    }

    if (c == R_EOF) {
        ps->next_token_val = R_NilValue;
        yytext[0] = 0;
        if (stext != st0) free(stext);
    	return ERROR;
    }

    CTEXT_PUSH(c); /* push closing quote */
    CTEXT_PUSH('\0');

    /* Copy the string as in the source to yytext, to use for parse data,
       of copy a message about it being to long to yytext. */

    if (!currtext_truncated)
        strcpy(yytext, currtext);
    else if (forSymbol || !use_wcs) {
        size_t total = strlen(stext);
        snprintf (yytext, MAXELTSIZE, "[%u chars quoted with '%c']",
                  (unsigned int)total, quote);
    }
    else 
        snprintf (yytext, MAXELTSIZE, "[%d wide chars quoted with '%c']", 
                  wcnt, quote);

    /* Create symbol or string from text in stext or wcs. */

    STEXT_PUSH('\0');
    if (forSymbol) {
	ps->next_token_val = install(stext);
	if (stext != st0) free(stext);
	return SYMBOL;
    } 
    else {
	if (use_wcs) {
	    if (oct_or_hex) {
                if (stext != st0) free(stext);
		error(_("mixing Unicode and octal/hex escapes in a string is not allowed"));
            }
	    if (wcnt > 10000) {
                if (stext != st0) free(stext);
		error(_("string at line %d containing Unicode escapes not in this locale\nis too long (max 10000 chars)"),
                      ps->sr->xxlineno);
            }
            WTEXT_PUSH(0);
            ps->next_token_val = mkStringUTF8(wcs,wcnt); /*incl terminator*/
	} 
        else
	    ps->next_token_val = mkString2(stext,  bp - stext - 1, oct_or_hex);
	if (stext != st0) free(stext);
	return STR_CONST;
    }
}


/* --------------------------------------------------------------------------
   THE LEXICAL ANALYZER
*/

/* Table of syntactic keywords and symbolic constants. */

static struct { char *name; int token; } keywords[] = {
    { "NULL",	    NULL_CONST   },
    { "NA",	    NUM_CONST    },  /* order of next 9 is significant below */
    { "TRUE",	    NUM_CONST    },
    { "FALSE",	    NUM_CONST    },
    { "Inf",	    NUM_CONST    },
    { "NaN",	    NUM_CONST    },
    { "NA_integer_", NUM_CONST   },
    { "NA_real_",    NUM_CONST   },
    { "NA_character_", NUM_CONST },
    { "NA_complex_", NUM_CONST   },
    { "function",   FUNCTION     },
    { "while",	    WHILE        },
    { "repeat",	    REPEAT       },
    { "for",	    FOR	         },
    { "if",	    IF	         },
    { "in",	    IN	         },
    { "else",	    ELSE         },
    { "next",	    NEXT         },
    { "break",	    BREAK        },
    { "..",         DOTDOT     },  /* delete if don't want .. to be reserved */
    { 0,	    0	       }
};


/* Check whether a string is a keyword.  Returns 0 if it is not a keyword.
   Returns 1 if it is a keyword, and also sets next_token_val to the
   associated value (constant, symbol, or R_NilValue for 'in' and 'else'). */

static int KeywordLookup(const char *s)
{
    int i;
    for (i = 0; keywords[i].name; i++) {
	if (strcmp(keywords[i].name, s) == 0) {
	    switch (keywords[i].token) {
	    case NULL_CONST:
		ps->next_token_val = R_NilValue;
		break;
	    case NUM_CONST:
                switch(i) {
                case 1:
                    ps->next_token_val = ScalarLogicalMaybeConst(NA_LOGICAL);
                    break;
                case 2:
                    ps->next_token_val = ScalarLogicalMaybeConst(1);
                    break;
                case 3:
                    ps->next_token_val = ScalarLogicalMaybeConst(0);
                    break;
                case 4:
                    ps->next_token_val = allocVector1REAL();
                    REAL(ps->next_token_val)[0] = R_PosInf;
                    break;
                case 5:
                    ps->next_token_val = allocVector1REAL();
                    REAL(ps->next_token_val)[0] = R_NaN;
                    break;
                case 6:
                    ps->next_token_val = ScalarIntegerMaybeConst(NA_INTEGER);
                    break;
                case 7:
                    ps->next_token_val = allocVector1REAL();
                    REAL(ps->next_token_val)[0] = NA_REAL;
                    break;
                case 8:
                    ps->next_token_val = allocVector(STRSXP, 1);
                    SET_STRING_ELT_NA(ps->next_token_val, 0);
                    break;
                case 9:
                    ps->next_token_val = allocVector(CPLXSXP, 1);
                    COMPLEX(ps->next_token_val)[0].r = NA_REAL;
                    COMPLEX(ps->next_token_val)[0].i = NA_REAL;
                    break;
                }
		break;
	    case FUNCTION:
		ps->next_token_val = R_FunctionSymbol;
		break;
	    case WHILE:
		ps->next_token_val = R_WhileSymbol;
		break;
	    case REPEAT:
		ps->next_token_val = R_RepeatSymbol;
		break;
	    case FOR:
		ps->next_token_val = R_ForSymbol;
		break;
	    case IF:
		ps->next_token_val = R_IfSymbol;
		break;
	    case NEXT:
		ps->next_token_val = R_NextSymbol;
		break;
	    case BREAK:
		ps->next_token_val = R_BreakSymbol;
		break;
		break;
	    case IN:
	    case ELSE:
		ps->next_token_val = R_NilValue;
		break;
	    case SYMBOL:
		ps->next_token_val = install(s);
		break;
	    }
	    return keywords[i].token;
	}
    }
    return 0;
}


/* Process a special operator beginning with '%', setting next_token_val
   to a symbol for it.  The value returned is SYMBOL or ERROR (if operator
   is incomplete). */

static int SpecialValue(int c)
{
    DECLARE_YYTEXT_BUFP(yyp);
    YYTEXT_PUSH(c, yyp);
    while ((c = xxgetc()) != R_EOF && c != '%') {
	if (c == '\n') {
	    xxungetc(c);
	    return ERROR;
	}
	YYTEXT_PUSH(c, yyp);
    }
    if (c == '%')
	YYTEXT_PUSH(c, yyp);
    YYTEXT_PUSH('\0', yyp);
    ps->next_token_val = install(yytext);
    return SPECIAL;
}


/* Process a symbol value, putting the symbol in next_token_val (or
   the corresponding numeric or logical value, for constants).  The
   return value is SYMBOL for regular symbols, or the appropriate token 
   code for reserved words. */

static int SymbolValue(int c)
{
    int previous_dots = -1;  /* # previous "." chars, but -1 for initial dots */
    int alphu;               /* whether it's either alphanumeric or underline */
    int kw;

    DECLARE_YYTEXT_BUFP(yyp);

    if(mbcslocale) {
	wchar_t wc; int i, clen;
	clen = mbcs_get_next(c, &wc);
	while (1) {
            if (c != '.')
                previous_dots = 0;
            else if (previous_dots != -1) 
                previous_dots += 1;
	    for (i = 0; i < clen; i++) {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
	    }
	    if (c == R_EOF)
                break;
	    if (c == '.') {
		clen = 1;
		continue;
	    }

            alphu = 0;
            if (c == '_') {
                clen = 1;
                alphu = 1;
            }
            else {
                clen = mbcs_get_next(c, &wc);
                if (iswalnum(wc))
                    alphu = 1;
            }
            if (!alphu) {
                xxungetc(c);
                break;
            }

            if (previous_dots > 1 && ps->parse_dotdot) {
                xxungetc(c);
                xxungetc('.'); YYTEXT_UNPUSH(yyp);
                xxungetc('.'); YYTEXT_UNPUSH(yyp);
                break;
            }
	}
    } 
    else {
	while (1) {
            if (c != '.')
                previous_dots = 0;
            else if (previous_dots != -1) 
                previous_dots += 1;
	    YYTEXT_PUSH(c, yyp);
            c = xxgetc();
	    if (c == R_EOF)
                break;
	    if (c == '.')
		continue;

            alphu = 0;
            if (c == '_') 
                alphu = 1;
            else if (isalnum(c))
                alphu = 1;
            if (!alphu) {
                xxungetc(c);
                break;
            }

            if (previous_dots > 1 && ps->parse_dotdot) {
                xxungetc(c);
                xxungetc('.'); YYTEXT_UNPUSH(yyp);
                xxungetc('.'); YYTEXT_UNPUSH(yyp);
                break;
            }
	}
    }

    YYTEXT_PUSH('\0', yyp);

    kw = KeywordLookup(yytext);
    if (kw != 0 && (ps->parse_dotdot || kw != DOTDOT))
	return kw;
    
    ps->next_token_val = install(yytext);
    return SYMBOL;
}


/* Skip whitespace characters, starting with the character passed,
   and stopping on '\n', R_EOF, or a non-whitespace character.  The 
   character stopped on is returned. */

static int skip_whitespace (int c)
{
    int NBSP = ' ';

#if defined(Win32) || defined(__STDC_ISO_10646__)
    int i, clen;
    wchar_t wc;  /* wctype functions need Unicode wchar_t */
#endif

#ifdef Win32
    if (!mbcslocale) NBSP = 0xa0; /* 0xa0 is NBSP in 8-bit Windows locales */
#endif 

    for (;;) {

        if (c == '\n' || c == R_EOF)
            return c;

        if (c != ' ' && c != '\t' && c != '\f' && c != NBSP) {
#           if defined(Win32) || defined(__STDC_ISO_10646__)
            {   if (mbcslocale) {
                    if ((unsigned int) c < 0x80)
                        return c;
                    clen = mbcs_get_next(c, &wc);
                    if ( ! Ri18n_iswctype (wc, Ri18n_wctype("blank")))
                        return c;
                    for (i = 1; i < clen; i++)
                        c = xxgetc();
                }
                else
                    return c;
            }
#           else
                return c;
#           endif
        }

        c = xxgetc();
    }
}


/* Set the name of the source file that text is coming from. */

static void set_parse_filename(SEXP newname) 
{
    SEXP class;

    if (!isEnvironment(ps->sr->SrcFile)) {
        REPROTECT(ps->sr->SrcFile = duplicate(newname), ps->sr->SrcFileProt);
        return;
    }

    PROTECT(newname);    

    SEXP oldname = findVar(install("filename"), ps->sr->SrcFile);
    if (isString(oldname) && length(oldname) > 0 &&
         strcmp (CHAR(STRING_ELT(oldname,0)), CHAR(STRING_ELT(newname,0)))==0) {
        UNPROTECT(1);
        return;
    }

    REPROTECT (ps->sr->SrcFile =
                 NewEnvironment (R_NilValue, R_NilValue, R_EmptyEnv),
               ps->sr->SrcFileProt);
    set_var_in_frame (install("filename"), newname, ps->sr->SrcFile,
                      TRUE, 3);

    if (ps->sr->keepSrcRefs) {
        set_var_in_frame (install("original"), ps->sr->Original, 
                          ps->sr->SrcFile, TRUE, 3);
        PROTECT(class = allocVector(STRSXP, 2));
        SET_STRING_ELT(class, 0, mkChar("srcfilealias"));
        SET_STRING_ELT(class, 1, mkChar("srcfile"));
        setAttrib(ps->sr->SrcFile, R_ClassSymbol, class);
        UNPROTECT(1);
    } 

    UNPROTECT(1);
}


/* Skip a comment, returning the character ending it ('\n' or R_EOF).
   Also processes comments that are #line directives.  The initial #
   will have already been read. 

   Only short comments (<= 200 chars) are recorded for parse data (longer
   ones can be fetched at the R level).  Line directives are not recorded. */

#define MAX_REC_COMMENT 200  /* must be less than MAXELTSIZE == sizeof yytext */

static int skip_comment (void)
{
    int directive = FALSE;
    int hasfile = FALSE;
    int linenumber;
    int text_ix;
    source_location loc;
    char *dir;
    int c;

    loc.first_parsed = ps->sr->xxparseno;
    loc.first_column = ps->sr->xxcolno;

    c = '#';  /* character that will have been read before */
    yytext[0] = c;
    text_ix = 1;

    /* Start processing it as a #line directive if it is one. */

    c = xxgetc();

    if (ps->sr->xxcolno != 2)  /* directives are only at beginning of line */
        goto skip;

    for (dir = "line"; *dir; dir++) {
        if (c != *dir)
            goto skip;
        yytext[text_ix++] = c;
        c = xxgetc();
    }

    text_ix = 0;  /* Don't record directive for parse data */

    c = skip_whitespace(xxgetc());
    if (!isdigit(c)) 
        goto skip;

    if (NumericValue(c) != NUM_CONST)
        goto skip;

    directive = TRUE;
    linenumber = atoi(yytext);

    c = skip_whitespace(xxgetc());

    if (c == '"') {
        if (StringValue(c, FALSE) == STR_CONST)
            hasfile = TRUE;
        c = xxgetc();
    }

    /* Skip to end of comment. */

  skip:
    while (c != '\n' && c != R_EOF) {
        if (text_ix) {
            if (text_ix >= MAX_REC_COMMENT)
                text_ix = 0;
            else
                yytext[text_ix++] = c;
        }
        c = xxgetc();
    }

    yytext[text_ix] = 0;

    if (ps->keep_source) {
        SEXP rec = start_parseData_record 
               (&loc, directive ? "LINE_DIRECTIVE" : "COMMENT", yytext, TRUE);
        if (c == '\n') xxungetc(c);  /* newline shouldn't be in parse record */
        loc.last_parsed = ps->sr->xxparseno;
        loc.last_column = ps->sr->xxcolno;
        end_parseData_record(rec,&loc);
        if (ps->sr->unattached_comment_id == 0)
            ps->sr->unattached_comment_id = PDATA_IDATA_VAL (rec, PDATA_ID);
        if (c == '\n') xxgetc();
    }

    /* Finish processing directive. */

    if (directive) {

        /* Set file name if there was one. */

        if (hasfile)
	    set_parse_filename(ps->next_token_val);

        /* Set the line number only now, since StringValue might raise an error,
           and we don't want the ungetc above to set it back.  Note that 
           we don't change xxparseno, which counts physical lines. */

        ps->sr->xxlineno = linenumber;

        /* Stop the directive from appearing in the error context. */

        ps->ParseContext[ps->ParseContextLast] = '\0'; 
    }

    return c;
}


/* Called following '.'.  We only care if it's an ANSI digit or not. */

static int nextisdigit(void)
{
    int k, c;
    c = xxgetc();
    k = isdigit(c);
    xxungetc(c);
    return k;
}


/* Returns whether the next character is the one passed, advancing to
   the next character only if it is (in which case the expected character
   is also appended to yytext). */

static int nextchar(int expect)
{
    int c = xxgetc();
    if (c == expect) {
        int l = strlen(yytext);
        yytext[l] = c;
        yytext[l+1] = 0;
	return 1;
    }
    else {
	xxungetc(c);
        return 0;
    }
}


/* Get a token.

   Passed the first non-whitespace character of the next token.  Returns
   the token code (or ERROR if the next token is malformed).  Will also
   set next_token_val to an associated SEXP (R_NilValue if none).

   If no_sym_un is non-zero, symbols are not expected, which therefore
   allows the .. operator to be recognized.  (But no error is signaled
   here if a symbol is seen.)

   The character after the token may have been looked at, but if so xxungetc
   will have been called to put it back. */

static int token (int c, int no_sym_un)
{
    wchar_t wc;

    ps->next_token_val = R_NilValue;
    yytext[0] = 0;

    /* Hard and soft end of file.  Soft end of file comes at the end of a
             line of input, which may or may not be the actual end. */

    if (c == R_EOF)
        return END_OF_INPUT;

    if (c == '\n')
        return c;

    /* Literal numbers - since either digits or symbols can start with '.',
       we need to check whether the next character is a digit. */

    if (isdigit(c) || c == '.' && nextisdigit())
        return NumericValue(c);

    /* Literal strings */

    if (c == '\"' || c == '\'')
	return StringValue(c, FALSE);

    /* Special functions */

    if (c == '%')
	return SpecialValue(c);

    /* The .. operator.  Only recognized if no_sym_un is true (and if 
       parse_dotdot is enabled). */

    if (ps->parse_dotdot && no_sym_un && c == '.' && nextchar('.')) {
        strcpy(yytext,"..");
        ps->next_token_val = R_DotDotSymbol;
        return DOTDOT;
    }

    /* Symbols (functions, constants and variables). */

    if (c == '.')
        return SymbolValue(c);
    if (c == '`')
	return StringValue(c, TRUE);
    if(mbcslocale) {
	mbcs_get_next(c, &wc);
	if (iswalpha(wc)) return SymbolValue(c);
    }
    else
	if (isalpha(c)) return SymbolValue(c);

    /* Simple and compound tokens */

    yytext[0] = c;
    yytext[1] = 0;

    switch (c) {
    case '<':
	if (nextchar('=')) {
	    ps->next_token_val = R_LeSymbol;
	    return LE;
	}
	if (nextchar('-')) {
	    ps->next_token_val = R_LocalAssignSymbol;
	    return LEFT_ASSIGN;
	}
	if (nextchar('<')) {
	    if (nextchar('-')) {
		ps->next_token_val = R_GlobalAssignSymbol;
		return LEFT_ASSIGN;
	    }
	    else
		return ERROR;
	}
	ps->next_token_val = R_LtSymbol;
	return LT;
    case '-':
	if (nextchar('>')) {
	    if (nextchar('>')) {
		ps->next_token_val = R_GlobalRightAssignSymbol;
		return RIGHT_ASSIGN;
	    }
	    else {
		ps->next_token_val = R_LocalRightAssignSymbol;
		return RIGHT_ASSIGN;
	    }
	}
	ps->next_token_val = R_SubSymbol;
	return '-';
    case '>':
	if (nextchar('=')) {
	    ps->next_token_val = R_GeSymbol;
	    return GE;
	}
	ps->next_token_val = R_GtSymbol;
	return GT;
    case '!':
	if (nextchar('=')) {
	    ps->next_token_val = R_NeSymbol;
	    return NE;
	}
        if (no_sym_un && nextchar('!')) {
	    ps->next_token_val = R_BangBangSymbol;
	    return BANGBANG;
        }
	ps->next_token_val = R_NotSymbol;
	return '!';
    case '=':
	if (nextchar('=')) {
	    ps->next_token_val = R_EqSymbol;
	    return EQ;
	}
	ps->next_token_val = R_EqAssignSymbol;
	return EQ_ASSIGN;
    case ':':
	if (nextchar(':')) {
	    if (nextchar(':')) {
		ps->next_token_val = R_TripleColonSymbol;
		return NS_GET_INT;
	    }
	    else {
		ps->next_token_val = R_DoubleColonSymbol;
		return NS_GET;
	    }
	}
	if (nextchar('=')) {
	    ps->next_token_val = R_ColonAssignSymbol;
	    return COLON_ASSIGN;
	}
	ps->next_token_val = R_ColonSymbol;
	return ':';
    case '&':
	if (nextchar('&')) {
	    ps->next_token_val = R_And2Symbol;
	    return AND2;
	}
	ps->next_token_val = R_AndSymbol;
	return AND;
    case '|':
	if (nextchar('|')) {
	    ps->next_token_val = R_Or2Symbol;
	    return OR2;
	}
	ps->next_token_val = R_OrSymbol;
	return OR;
    case '{':
	ps->next_token_val = R_BraceSymbol;
	return c;
    case '}':
	return c;
    case '(':
	ps->next_token_val = R_ParenSymbol;
	return c;
    case ')':
	return c;
    case '[':
	if (nextchar('[')) {
	    ps->next_token_val = R_Bracket2Symbol;
	    return LBB;
	}
	ps->next_token_val = R_BracketSymbol;
	return c;
    case ']':
	return c;
    case '?':
	ps->next_token_val = R_QuerySymbol;
	return c;
    case '*':
	if (nextchar('*')) {
            /* We accept ** as a synonym for ^, with its own token type 
               and primitive definition. */
	    ps->next_token_val = R_Expt2Symbol;
            return EXPT2;
        }
        ps->next_token_val = R_MulSymbol;
	return c;
    case '+':
        ps->next_token_val = R_AddSymbol;
        return c;
    case '/':
        ps->next_token_val = R_DivSymbol;
        return c;
    case '^':
        ps->next_token_val = R_ExptSymbol;
        return c;
    case '~':
        ps->next_token_val = R_TildeSymbol;
        return c;
    case '$':
        ps->next_token_val = R_DollarSymbol;
        return c;
    case '@':
        ps->next_token_val = R_AtSymbol;
        return c;
    case '_':
        ps->next_token_val = R_MissingUnder;
        return c;
    default:
	return c;
    }
}


/* Get the next token after skipping whitespace and put it in
   next_token.  Also sets next_token_val, newline_before_token,
   token_loc, and prev_token_loc.  Always sets newline_before_token
   to 1 when returning END_OF_INPUT or '\n', regardless of 
   whether a newline was actually present before. 

   If no_sym_un is non-zero, symbols and unary operators are not
   expected, which therefore allows the .. and !! operators to be
   recognized.  No error is signaled here if a symbol or unary
   operator is seen anyway.  But if a second symbol is "gradient",
   no parse data record is created for it - instead a previous "with",
   "track", "back", or "compute" record is modified appropriately.

   Returns 0 if end of file was immediately encountered, with no
   whitespace before, and 1 if not (even when END_OF_INPUT is the 
   next token). 

   The value in next_token_val is protected from immediate reclamation
   via the ps->sr->TokenValProt index, but must be protected by the
   caller if it will be used after the following token is obtained. */

static int get_next_token(int no_sym_un)
{
    int c, val;

    ps->prev_token_loc = ps->token_loc;

    ps->newline_before_token = 0;

    c = xxgetc();
    val = c != R_EOF;

    c = skip_whitespace(c);
    if (c == '#')
        c = skip_comment();
    if (c == '\n' || c == R_EOF)
        ps->newline_before_token = 1;

    ps->token_loc.first_line   = ps->sr->xxlineno;
    ps->token_loc.first_column = ps->sr->xxcolno;
    ps->token_loc.first_byte   = ps->sr->xxbyteno;
    ps->token_loc.first_parsed = ps->sr->xxparseno;

    ps->next_token = token(c,no_sym_un);

    REPROTECT (ps->next_token_val, ps->sr->TokenValProt);

    ps->token_loc.last_line    = ps->sr->xxlineno;
    ps->token_loc.last_column  = ps->sr->xxcolno;
    ps->token_loc.last_byte    = ps->sr->xxbyteno;
    ps->token_loc.last_parsed  = ps->sr->xxparseno;

    if (ps->next_token != END_OF_INPUT && ps->next_token != '\n'
         && (!no_sym_un || ps->next_token_val != R_GradientSymbol)) {
        SEXP rec;
        char t[4] = { '\'', (char) ps->next_token, '\'', 0 };
        rec = start_parseData_record (&ps->token_loc, 
                                      ps->next_token < 256 ? t
                                       : pdata_token_name[ps->next_token-256],
                                      yytext, TRUE);
        end_parseData_record (rec, &ps->token_loc);
    }

    return val;
}


/* --------------------------------------------------------------------------
   ROUTINE USED ONLY EXTERNALLY
*/

/* Return 1 if 'name' is a valid name or 0 otherwise.  Not used by the
   parser itself, but defined here since it needs to know which names 
   are reserved words. */

int isValidName(const char *name)
{
    int previous_dots = -1;  /* # previous "." chars, but -1 for initial dots */
    const char *p = name;
    int i;

    if (!R_parse_dotdot && strcmp(name,"..") == 0)
        return 1;  /* .. is OK when not being parsed as an operator */

    if(mbcslocale) {

	/* the only way to establish which chars are alpha etc is to
	   use the wchar variants */
	int n = strlen(name), used;
	wchar_t wc;
	used = Mbrtowc(&wc, p, n, NULL); p += used; n -= used;
	if (used == 0)
            return 0;
	if (wc != L'.' && !iswalpha(wc))
            return 0;
	if (wc == L'.') {
	    /* We don't care about other than ASCII digits */
	    if (isdigit(0xff & (int)*p))
                return 0;
	    /* Mbrtowc(&wc, p, n, NULL); if(iswdigit(wc)) return 0; */
	}

        for (;;) {
            if (!iswalnum(wc) && wc != L'.' && wc != L'_')
                return 0;
            if (wc == L'.') {
                if (previous_dots != -1) previous_dots += 1;
            }
            else {
                if (previous_dots > 1 && R_parse_dotdot)
                    return 0;
                previous_dots = 0;
            }
            if (*p == 0) 
                break;
            used = Mbrtowc(&wc, p, n, NULL); p += used; n -= used;
        }

    } else {

	int c = 0xff & *p++;  /* char may be a signed type */
	if (c != '.' && !isalpha(c) )
            return 0;
        if (*p == 0)  /* one character name, never a reserved word */
            return 1;
	if (c == '.' && isdigit(0xff & (int)*p))
            return 0;

        for (;;) {
            if (!isalnum(c) && c != '.' && c != '_')
                return 0;
            if (c == '.') {
                if (previous_dots != -1) previous_dots += 1;
            }
            else {
                if (previous_dots > 1 && R_parse_dotdot)
                    return 0;
                previous_dots = 0;
            }
            if (*p == 0) 
                break;
            c = 0xff & *p++;
        }
    }

    /* Check whether it's a reserved word. */

    if (name[1] == 0) /* reserved words all at least length 2 */
        return 1;

    for (i = 0; keywords[i].name != NULL; i++)
	if (name[0] == keywords[i].name[0] /* quick pre-test */ 
         && name[1] == keywords[i].name[1]
         && strcmp(keywords[i].name+2, name+2) == 0)
            return 0;

    return 1;
}
